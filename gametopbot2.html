<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <title>COMMANDO¬∑BULLETS¬∑NOW¬∑KILL¬∑FIXED</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; background: #0a1a1f; display: flex; justify-content: center; align-items: center; font-family: 'Courier New', Courier, monospace; touch-action: pan-y; }
        .arcade-cabinet { background: linear-gradient(145deg, #1c3840, #152a30); padding: 15px 15px 20px; border-radius: 30px 30px 15px 15px; box-shadow: 0 15px 0 #0c1c22, 0 20px 30px rgba(0,0,0,0.8); border-bottom: 8px solid #2d5662; max-width: 1000px; width: 100%; margin: auto; display: flex; flex-direction: column; }
        canvas { display: block; margin: 0 auto; border: 6px solid #2e5665; border-radius: 16px; box-shadow: inset 0 0 0 4px #6d9eb0, 0 8px 0 #142f39; width: 100%; height: auto; aspect-ratio: 800 / 500; image-rendering: crisp-edges; image-rendering: pixelated; background: #10262e; }
        .panel { display: flex; justify-content: space-between; align-items: center; margin-top: 12px; color: #b9f3ff; text-shadow: 2px 2px 0 #0f2a30; background: linear-gradient(145deg, #1f424b, #17323a); padding: 8px 16px; border-radius: 40px; border-bottom: 6px solid #0e262c; font-size: clamp(14px,4vw,20px); font-weight: 900; letter-spacing: 2px; flex-wrap: wrap; }
        .scores, .health { display: flex; align-items: center; gap: 5px; background: #10262e; padding: 4px 12px; border-radius: 30px; border-bottom: 4px solid #308595; color: #fdffb8; }
        .btn { background: #cf4e5c; color: white; border: none; border-radius: 40px; padding: 8px 18px; font-size: clamp(16px,4vw,22px); font-weight: bold; border-bottom: 6px solid #822c36; cursor: pointer; transition: 0.06s; font-family: 'Courier New', monospace; text-shadow: 2px 2px 0 #4e1e24; letter-spacing: 2px; }
        .btn:active { background: #ec6a7a; border-bottom-width: 3px; transform: translateY(3px); }
        .legend { color: #b3ecff; font-size: 15px; display: flex; gap: 20px; background: #16353f; padding: 8px 16px; border-radius: 40px; border-bottom: 5px solid #0b1f24; flex-wrap: wrap; justify-content: center; margin-top: 10px; }
        .touch-controls { display: none; margin-top: 15px; flex-direction: column; gap: 10px; background: #2b4b55; border-radius: 40px; border-bottom: 8px solid #16333a; padding: 15px 10px; touch-action: none; }
        .touch-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .joystick { width: 140px; height: 140px; background: #1f3a40; border-radius: 50%; border-bottom: 8px solid #0f262c; display: flex; justify-content: center; align-items: center; position: relative; touch-action: none; box-shadow: inset 0 0 10px #0a1a1f; }
        .joystick-base { width: 100px; height: 100px; background: radial-gradient(circle at 30% 30%, #3f5f68, #1f3a40); border-radius: 50%; border-bottom: 6px solid #1a2f35; display: flex; justify-content: center; align-items: center; position: relative; }
        .joystick-handle { width: 60px; height: 60px; background: radial-gradient(circle at 30% 30%, #7fa3ac, #4f6f78); border-radius: 50%; border-bottom: 6px solid #3a555e; display: flex; justify-content: center; align-items: center; box-shadow: inset 0 -2px 0 #3a555e, 0 0 10px #a0d0d0; transition: 0.02s; position: relative; left: 0; top: 0; touch-action: none; }
        .ab-buttons { display: flex; gap: 15px; margin-right: 10px; }
        .ab { background: radial-gradient(circle at 30% 30%, #b35a6a, #9e4a5c); width: 80px; height: 80px; border-radius: 50%; border-bottom: 8px solid #632c38; display: flex; justify-content: center; align-items: center; font-size: 28px; color: white; text-shadow: 3px 3px 0 #3a1e24; box-shadow: inset 0 -4px 0 #753a46, 0 0 15px #ff8c8c; cursor: pointer; touch-action: none; }
        .ab:active { border-bottom-width: 3px; transform: translateY(5px); background: radial-gradient(circle at 30% 30%, #d06a7a, #b35a6a); }
        .mobile-info { display: none; color: #b3ecff; background: #16353f; padding: 8px 16px; border-radius: 40px; border-bottom: 5px solid #0b1f24; font-size: 15px; justify-content: space-around; align-items: center; width: 100%; }
        .mobile-info span { background: #0c2a30; padding: 4px 12px; border-radius: 20px; }
        @media (max-width:900px) { 
            .touch-controls { display: flex !important; } 
            .legend { display: none; } 
            .mobile-info { display: flex !important; } 
            .joystick { width: 120px; height: 120px; } 
            .joystick-base { width: 90px; height: 90px; } 
            .joystick-handle { width: 55px; height: 55px; } 
            .ab { width: 70px; height: 70px; font-size: 26px; } 
        }
    </style>
</head>
<body>
<div class="arcade-cabinet" id="gameCabinet">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <div class="panel">
        <div class="scores">üéØ <span id="scoreDisplay">00000</span></div>
        <div class="scores">üèÜ <span id="highScoreDisplay">00000</span></div>
        <div class="health">‚ù§Ô∏è <span id="healthDisplay">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span></div>
        <button class="btn" id="restartButton">‚Üª RESTART</button>
    </div>
    
    <div class="legend">
        <span><i>‚Üê‚Üí‚Üë‚Üì</i> MOVE</span>
        <span><i>STICK</i> AIM + SHOOT</span>
        <span><i>FIRE</i> HOLD TO SHOOT</span>
        <span><i>BOMB</i> CLEAR</span>
        <span id="levelDisplayDesktop">LVL 1 ¬∑ JUNGLE</span>
    </div>

    <div class="touch-controls" id="touchControls">
        <div class="touch-row">
            <div class="joystick" id="joystickContainer">
                <div class="joystick-base" id="joystickBase">
                    <div class="joystick-handle" id="joystickHandle"></div>
                </div>
            </div>
            <div class="ab-buttons">
                <div class="ab" id="touchFire">üî•</div>
                <div class="ab" id="touchBomb">üí£</div>
            </div>
        </div>
        <div class="mobile-info">
            <span id="mobileLevelDisplay">LVL 1 ¬∑ JUNGLE</span>
            <span>üéÆ MOVE / AIM</span>
            <span>üí£ BOMB</span>
        </div>
    </div>
</div>

<script>
    (function(){
        'use strict';
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;
        ctx.imageSmoothingEnabled = false;

        // ----------  WORLD & CAMERA ----------
        const WORLD_SIZE = 2000;
        const VIEWPORT_W = 800, VIEWPORT_H = 500;
        let cameraX = 0, cameraY = 0;

        // ----------  GLOBAL STATE ----------
        let gameActive = true, gameOver = false, victoryFlag = false, currentLevel = 1, MAX_LEVEL = 6, frame = 0, animFrameId = null;
        let score = 0, highScore = 0;
        try { highScore = localStorage.getItem('commandoDeluxe') ? parseInt(localStorage.getItem('commandoDeluxe')) : 0; } catch(e) { highScore = 0; }
        let playerHealth = 8, MAX_HEALTH = 8;

        // ----------  11 POWER‚ÄëUPS! ----------
        let rapidFire = false, rapidTimer = 0;
        let shieldActive = false, shieldTimer = 0;
        let spreadShot = false, spreadTimer = 0;
        let invincibleStar = false, starTimer = 0;
        let homingMissiles = false, homingTimer = 0;
        let piercingShots = false, piercingTimer = 0;
        let speedBoost = false, speedTimer = 0;
        let timeSlow = false, slowTimer = 0;
        let damageBoost = false, damageTimer = 0;
        let bombCharge = false, bombChargeTimer = 0;
        let ricochet = false, ricochetTimer = 0;
        let regen = false, regenTimer = 0, regenCounter = 0;
        let maxHealthUp = false, maxHealthTimer = 0;

        // ----------  PLAYER ----------
        const PLAYER_WIDTH = 44, PLAYER_HEIGHT = 44;
        const BASE_SPEED = 4.2;
        let player = { x: 400, y: 400, vx: 0, vy: 0, aimAngle: 0, shootTimer: 0, invincible: 0, bombCooldown: 0, walkFrame: 0 };

        // ----------  LEVEL DESIGN ‚Äì DA VINCI STYLE ----------
        let walls = [], enemySpawners = [], exitDoor = null, levelName = "", levelTheme = "";
        let bullets = [], enemies = [], enemyBullets = [], explosions = [], pickups = [], particles = [];

        // ----------  KEYBOARD / TOUCH STATE ----------
        const keys = { left: false, right: false, up: false, down: false, fire: false, bomb: false };

        // ----------  HELPER ‚Äì ADD WALL CLUSTER ----------
        function addWallCluster(sx, sy, cols, rows, w, h) {
            for (let i=0; i<cols; i++) for (let j=0; j<rows; j++) walls.push({ x: sx + i*(w+20), y: sy + j*(h+20), w, h });
        }

        // ----------  üî´ BULLET ‚Äì SIMPLE, RELIABLE, DEADLY ----------
        function createBullet(x, y, vx, vy) {
            return { 
                x: x - 16, y: y - 16,    // 32x32 bullet
                w: 32, h: 32, 
                vx, vy, 
                life: 80,
                piercing: piercingShots ? 2 : 0,
                damage: damageBoost ? 2 : 1, // ALWAYS a number
                ricochetLeft: ricochet ? 1 : 0,
                homing: null,
                homingStrength: 0.1,
                prevX: x - 16, // for continuous collision
                prevY: y - 16
            };
        }

        // ----------  üåç 6 ARTISTIC LEVELS ‚Äì SAME DA VINCI LAYOUTS ----------
        function buildLevel(level) {
            walls = []; enemySpawners = []; exitDoor = null;
            walls.push({ x:0, y:0, w:WORLD_SIZE, h:10 }, { x:0, y:WORLD_SIZE-10, w:WORLD_SIZE, h:10 }, { x:0, y:0, w:10, h:WORLD_SIZE }, { x:WORLD_SIZE-10, y:0, w:10, h:WORLD_SIZE });

            if (level === 1) { 
                levelName = "SUNKEN JUNGLE"; levelTheme = "jungle";
                for (let i=0;i<16;i++) { let angle = (i/16)*Math.PI*2; let cx = 500 + Math.cos(angle)*240; let cy = 400 + Math.sin(angle)*240; walls.push({ x: cx-25, y: cy-25, w: 50, h: 50 }); }
                addWallCluster(900,500, 2,2, 40,40); addWallCluster(1300,300, 3,1, 60,60); addWallCluster(1600,600, 2,2, 50,50);
                enemySpawners = [ 
                    { x:380,y:380,type:'sniper',behavior:'snipe' }, { x:620,y:250,type:'infantry',behavior:'chase' }, 
                    { x:750,y:500,type:'drone',behavior:'flee' }, { x:900,y:600,type:'heavy',behavior:'chase' }, 
                    { x:1100,y:350,type:'jumper',behavior:'jump' }, { x:1350,y:550,type:'sniper',behavior:'snipe' }, 
                    { x:1550,y:400,type:'infantry',behavior:'chase' }, { x:1750,y:700,type:'boss_lieutenant',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:750 };
            } else if (level === 2) { 
                levelName = "MACHINE COMPLEX"; levelTheme = "factory";
                for (let i=0;i<12;i++) { let angle = (i/12)*Math.PI*2; let cx = 600 + Math.cos(angle)*200; let cy = 400 + Math.sin(angle)*200; walls.push({ x: cx-15, y: cy-15, w: 30, h: 30 }); }
                walls.push({ x:200,y:200,w:500,h:20 }, { x:200,y:600,w:500,h:20 }, { x:1100,y:300,w:500,h:20 }, { x:1100,y:700,w:500,h:20 });
                enemySpawners = [ 
                    { x:250,y:250,type:'heavy',behavior:'chase' }, { x:450,y:450,type:'infantry',behavior:'chase' }, 
                    { x:650,y:350,type:'drone',behavior:'flee' }, { x:850,y:550,type:'sniper',behavior:'snipe' }, 
                    { x:1050,y:200,type:'jumper',behavior:'jump' }, { x:1300,y:650,type:'infantry',behavior:'patrol' }, 
                    { x:1550,y:400,type:'heavy',behavior:'chase' }, { x:1750,y:600,type:'boss_lieutenant',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:800 };
            } else if (level === 3) { 
                levelName = "ALIEN NEXUS"; levelTheme = "alien";
                for (let r=1;r<=5;r++) for (let i=0;i<8;i++) { let angle = (i/8)*Math.PI*2 + r*0.5; let cx = 500 + Math.cos(angle)*r*70; let cy = 400 + Math.sin(angle)*r*70; walls.push({ x: cx-10, y: cy-10, w: 20, h: 20 }); }
                walls.push({ x:480, y:380, w:80, h:80 });
                enemySpawners = [ 
                    { x:550,y:250,type:'drone',behavior:'flee' }, { x:650,y:500,type:'jumper',behavior:'jump' }, 
                    { x:400,y:600,type:'infantry',behavior:'chase' }, { x:300,y:300,type:'sniper',behavior:'snipe' }, 
                    { x:700,y:700,type:'heavy',behavior:'chase' }, { x:850,y:150,type:'drone',behavior:'flee' }, 
                    { x:1100,y:500,type:'infantry',behavior:'patrol' }, { x:1400,y:300,type:'jumper',behavior:'jump' }, 
                    { x:1700,y:600,type:'boss_lieutenant',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:700 };
            } else if (level === 4) { 
                levelName = "GLACIAL PEAK"; levelTheme = "ice";
                walls.push({ x:200,y:200,w:30,h:400 }, { x:400,y:250,w:30,h:400 }, { x:600,y:150,w:30,h:500 }, { x:800,y:300,w:30,h:450 }, 
                           { x:1000,y:200,w:30,h:500 }, { x:1200,y:350,w:30,h:400 }, { x:1400,y:250,w:30,h:450 }, { x:1600,y:300,w:30,h:400 });
                addWallCluster(300,550,2,2,50,50); addWallCluster(700,600,2,2,50,50); addWallCluster(1100,600,2,2,50,50); addWallCluster(1500,550,2,2,50,50);
                enemySpawners = [ 
                    { x:250,y:350,type:'sniper',behavior:'snipe' }, { x:500,y:550,type:'infantry',behavior:'chase' }, 
                    { x:750,y:250,type:'heavy',behavior:'chase' }, { x:1000,y:600,type:'drone',behavior:'flee' }, 
                    { x:1250,y:400,type:'jumper',behavior:'jump' }, { x:1500,y:700,type:'sniper',behavior:'snipe' }, 
                    { x:1650,y:450,type:'infantry',behavior:'patrol' }, { x:1800,y:350,type:'boss_lieutenant',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:850 };
            } else if (level === 5) { 
                levelName = "MOLTEN CORE"; levelTheme = "volcano";
                for (let i=0;i<8;i++) { let angle = (i/8)*Math.PI*2; let cx = 500 + Math.cos(angle)*300; let cy = 400 + Math.sin(angle)*300; walls.push({ x: cx-50, y: cy-20, w: 100, h: 20 }); }
                walls.push({ x:470, y:370, w:80, h:80 }, { x:100,y:150,w:600,h:20 }, { x:800,y:500,w:500,h:20 }, { x:200,y:750,w:400,h:20 });
                enemySpawners = [ 
                    { x:300,y:200,type:'heavy',behavior:'chase' }, { x:500,y:500,type:'jumper',behavior:'jump' }, 
                    { x:700,y:300,type:'drone',behavior:'flee' }, { x:950,y:450,type:'infantry',behavior:'chase' }, 
                    { x:1150,y:200,type:'sniper',behavior:'snipe' }, { x:1400,y:550,type:'heavy',behavior:'chase' }, 
                    { x:1600,y:400,type:'infantry',behavior:'patrol' }, { x:1750,y:600,type:'boss_lieutenant',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:700 };
            } else if (level === 6) { 
                levelName = "FINAL FORTRESS"; levelTheme = "fortress";
                for (let i=0;i<12;i++) { let angle = (i/12)*Math.PI*2; let cx = 600 + Math.cos(angle)*300; let cy = 400 + Math.sin(angle)*300; walls.push({ x: cx-30, y: cy-30, w: 60, h: 60 }); }
                walls.push({ x:550, y:350, w:100, h:100 }, { x:200,y:200,w:50,h:50 }, { x:200,y:600,w:50,h:50 }, { x:1700,y:200,w:50,h:50 }, { x:1700,y:600,w:50,h:50 });
                enemySpawners = [ 
                    { x:250,y:300,type:'heavy',behavior:'chase' }, { x:400,y:450,type:'sniper',behavior:'snipe' }, 
                    { x:550,y:250,type:'jumper',behavior:'jump' }, { x:700,y:550,type:'infantry',behavior:'chase' }, 
                    { x:850,y:350,type:'drone',behavior:'flee' }, { x:1000,y:500,type:'heavy',behavior:'chase' }, 
                    { x:1150,y:200,type:'boss_lieutenant',behavior:'boss' }, { x:1350,y:450,type:'boss_lieutenant',behavior:'boss' }, 
                    { x:1700,y:500,type:'boss',behavior:'boss' } 
                ];
                exitDoor = { x:1850, y:800 };
            }
        }

        // ----------  RESET GAME ----------
        function resetGame() {
            gameActive = true; gameOver = false; victoryFlag = false; 
            if (currentLevel > MAX_LEVEL) currentLevel = 1;
            score = 0; playerHealth = MAX_HEALTH = 8;
            rapidFire = false; rapidTimer = 0; shieldActive = false; shieldTimer = 0;
            spreadShot = false; spreadTimer = 0; invincibleStar = false; starTimer = 0;
            homingMissiles = false; homingTimer = 0; piercingShots = false; piercingTimer = 0;
            speedBoost = false; speedTimer = 0; timeSlow = false; slowTimer = 0;
            damageBoost = false; damageTimer = 0; bombCharge = false; bombChargeTimer = 0;
            ricochet = false; ricochetTimer = 0; regen = false; regenTimer = 0; regenCounter = 0;
            maxHealthUp = false; maxHealthTimer = 0;
            player = { x: 300, y: 300, vx:0, vy:0, aimAngle:0, shootTimer:0, invincible:0, bombCooldown:0, walkFrame:0 };
            bullets = []; enemies = []; enemyBullets = []; explosions = []; pickups = []; particles = [];
            buildLevel(currentLevel);
            cameraX = player.x - VIEWPORT_W/2; cameraY = player.y - VIEWPORT_H/2;
            cameraX = Math.max(0, Math.min(cameraX, WORLD_SIZE - VIEWPORT_W));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_SIZE - VIEWPORT_H));
            keys.left = false; keys.right = false; keys.up = false; keys.down = false; keys.fire = false; keys.bomb = false;
            updateUI();
        }

        // ----------  UI ----------
        function updateUI() {
            try {
                document.getElementById('scoreDisplay').innerText = String(Math.floor(score)).padStart(5,'0');
                document.getElementById('highScoreDisplay').innerText = String(highScore).padStart(5,'0');
                let healthBar = ''; for (let i=0; i<playerHealth; i++) healthBar += '‚ñà';
                document.getElementById('healthDisplay').innerText = healthBar.padEnd(MAX_HEALTH, '‚ñë');
                let levelText = `LVL ${currentLevel} ¬∑ ${levelName}`;
                document.getElementById('levelDisplayDesktop').innerText = levelText;
                let mobileLevel = document.getElementById('mobileLevelDisplay');
                if (mobileLevel) mobileLevel.innerText = levelText;
            } catch(e) {}
        }

        // ----------  COLLISION ‚Äì AABB, PROVEN TO WORK ----------
        function collides(r1, r2) { 
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y; 
        }
        
        function handleWallCollision(entity, w, h) {
            for (let wall of walls) {
                if (collides({x:entity.x, y:entity.y, w, h}, wall)) {
                    let dx = (entity.x + w/2) - (wall.x + wall.w/2), dy = (entity.y + h/2) - (wall.y + wall.h/2);
                    let overlapX = (w/2 + wall.w/2) - Math.abs(dx), overlapY = (h/2 + wall.h/2) - Math.abs(dy);
                    if (overlapX < overlapY) entity.x += dx > 0 ? overlapX : -overlapX; else entity.y += dy > 0 ? overlapY : -overlapY;
                }
            }
        }

        // ----------  CAMERA ----------
        function updateCamera() {
            let targetX = player.x + PLAYER_WIDTH/2 - VIEWPORT_W/2, targetY = player.y + PLAYER_HEIGHT/2 - VIEWPORT_H/2;
            targetX = Math.max(0, Math.min(targetX, WORLD_SIZE - VIEWPORT_W));
            targetY = Math.max(0, Math.min(targetY, WORLD_SIZE - VIEWPORT_H));
            cameraX += (targetX - cameraX) * 0.12; cameraY += (targetY - cameraY) * 0.12;
        }

        // ----------  PARTICLES ----------
        function addParticles(x, y, color, count = 8) {
            for (let i=0; i<count; i++) particles.push({ x, y, vx: (Math.random()-0.5)*6, vy: (Math.random()-0.5)*6, life: 20+Math.random()*20, color, size: 2+Math.floor(Math.random()*4) });
        }

        // ----------  PLAYER UPDATE ----------
        function updatePlayer() {
            if (!gameActive) return;
            if (playerHealth <= 0) { gameActive = false; gameOver = true; victoryFlag = false; return; }

            if (rapidTimer > 0) rapidTimer--; else rapidFire = false;
            if (shieldTimer > 0) shieldTimer--; else shieldActive = false;
            if (spreadTimer > 0) spreadTimer--; else spreadShot = false;
            if (starTimer > 0) starTimer--; else invincibleStar = false;
            if (homingTimer > 0) homingTimer--; else homingMissiles = false;
            if (piercingTimer > 0) piercingTimer--; else piercingShots = false;
            if (speedTimer > 0) speedTimer--; else speedBoost = false;
            if (slowTimer > 0) slowTimer--; else timeSlow = false;
            if (damageTimer > 0) damageTimer--; else damageBoost = false;
            if (bombChargeTimer > 0) bombChargeTimer--; else bombCharge = false;
            if (ricochetTimer > 0) ricochetTimer--; else ricochet = false;
            if (regenTimer > 0) { regenTimer--; regenCounter++; if (regenCounter > 40) { if (playerHealth < MAX_HEALTH) playerHealth++; regenCounter = 0; } } else regen = false;
            if (maxHealthTimer > 0) maxHealthTimer--; else maxHealthUp = false;

            let currentSpeed = BASE_SPEED * (speedBoost ? 1.7 : 1.0);
            let accelX = 0, accelY = 0;
            if (keys.left) accelX -= 1; if (keys.right) accelX += 1; if (keys.up) accelY -= 1; if (keys.down) accelY += 1;
            if (accelX !== 0 || accelY !== 0) {
                let len = Math.hypot(accelX, accelY); accelX /= len; accelY /= len;
                player.aimAngle = Math.atan2(accelY, accelX); player.walkFrame += 0.2;
            } else player.walkFrame = 0;
            player.vx = accelX * currentSpeed; player.vy = accelY * currentSpeed;
            player.x += player.vx; player.y += player.vy;
            handleWallCollision(player, PLAYER_WIDTH, PLAYER_HEIGHT);
            player.x = Math.max(20, Math.min(player.x, WORLD_SIZE - PLAYER_WIDTH - 20));
            player.y = Math.max(20, Math.min(player.y, WORLD_SIZE - PLAYER_HEIGHT - 20));

            // SHOOTING
            if (keys.fire && gameActive) {
                let fireRate = rapidFire ? 4 : (timeSlow ? 10 : 7);
                if (player.shootTimer <= 0) {
                    let cos = Math.cos(player.aimAngle), sin = Math.sin(player.aimAngle);
                    let bulletSpeed = 6.5;
                    let spawnX = player.x + PLAYER_WIDTH/2;
                    let spawnY = player.y + PLAYER_HEIGHT/2;
                    addParticles(spawnX + cos*25, spawnY + sin*25, '#ffd966', 5);

                    if (spreadShot) {
                        let b1 = createBullet(spawnX, spawnY, cos*bulletSpeed + sin*1.5, sin*bulletSpeed - cos*1.5);
                        let b2 = createBullet(spawnX, spawnY, cos*bulletSpeed*1.1, sin*bulletSpeed*1.1);
                        let b3 = createBullet(spawnX, spawnY, cos*bulletSpeed - sin*1.5, sin*bulletSpeed + cos*1.5);
                        bullets.push(b1, b2, b3);
                    } else if (homingMissiles) {
                        let nearest = null, nearestDist = Infinity;
                        for (let e of enemies) { 
                            let d = (e.x-player.x)**2+(e.y-player.y)**2; 
                            if (d<nearestDist) { nearest=e; nearestDist=d; } 
                        }
                        let b = createBullet(spawnX, spawnY, cos*5, sin*5);
                        b.homing = nearest;
                        bullets.push(b);
                    } else {
                        let b = createBullet(spawnX, spawnY, cos*bulletSpeed, sin*bulletSpeed);
                        bullets.push(b);
                    }
                    player.shootTimer = fireRate;
                }
            }
            if (player.shootTimer > 0) player.shootTimer--;

            // BOMB
            if (keys.bomb && player.bombCooldown <= 0 && gameActive) {
                addParticles(player.x+PLAYER_WIDTH/2, player.y+PLAYER_HEIGHT/2, '#ffaa00', 30);
                for (let i = enemies.length-1; i>=0; i--) {
                    let e = enemies[i];
                    if (Math.hypot(e.x-player.x, e.y-player.y) < 600) {
                        explosions.push({ x: e.x+e.w/2, y: e.y+e.h/2, life:30, radius:30 });
                        score += e.points; 
                        if (score > highScore) { highScore = score; localStorage.setItem('commandoDeluxe', highScore); }
                        addParticles(e.x+e.w/2, e.y+e.h/2, '#ff8c00', 20);
                        enemies.splice(i,1);
                    }
                }
                player.bombCooldown = bombCharge ? 90 : 300;
            }
            if (player.bombCooldown > 0) player.bombCooldown--;

            if (player.invincible > 0) player.invincible--;
            if (invincibleStar) player.invincible = Math.max(player.invincible, 2);
        }

        // ----------  ENEMY SPAWN ‚Äì ALL HEALTH ARE NUMBERS! (CRITICAL FIX) ----------
        function checkSpawners() {
            for (let i = enemySpawners.length-1; i>=0; i--) {
                let s = enemySpawners[i];
                if (Math.hypot(s.x-player.x, s.y-player.y) < 600 || s.behavior === 'boss') {
                    let enemy = null;
                    switch (s.type) {
                        case 'infantry': 
                            enemy = { x:s.x, y:s.y, w:30, h:30, health:2, points:30, type:'infantry', vx:0, vy:0, speed:1.3, shootTimer:80+Math.random()*80, behavior:'chase' }; 
                            break;
                        case 'heavy': 
                            enemy = { x:s.x, y:s.y, w:38, h:38, health:5, points:100, type:'heavy', vx:0, vy:0, speed:0.9, shootTimer:120+Math.random()*100, behavior:'chase' }; 
                            break;
                        case 'drone': 
                            enemy = { x:s.x, y:s.y, w:28, h:28, health:1, points:40, type:'drone', vx:0, vy:0, speed:1.7, shootTimer:90+Math.random()*90, behavior:'flee' }; 
                            break;
                        case 'sniper': 
                            enemy = { x:s.x, y:s.y, w:28, h:28, health:3, points:70, type:'sniper', vx:0, vy:0, speed:0.6, shootTimer:150+Math.random()*120, behavior:'snipe' }; 
                            break;
                        case 'jumper': 
                            enemy = { x:s.x, y:s.y, w:28, h:28, health:2, points:60, type:'jumper', vx:0, vy:0, speed:1.5, shootTimer:100+Math.random()*80, behavior:'jump', jumpTimer:30 }; 
                            break;
                        case 'boss_lieutenant': 
                            enemy = { x:s.x, y:s.y, w:56, h:56, health:35, points:400, type:'boss_lieutenant', vx:0, vy:0, speed:0.7, shootTimer:80+Math.random()*60, behavior:'boss', phase:1, maxHealth:35 }; 
                            break;
                        case 'boss': 
                            enemy = { x:s.x, y:s.y, w:70, h:70, health:80, points:1000, type:'boss', vx:0, vy:0, speed:0.6, shootTimer:60+Math.random()*40, behavior:'boss', phase:1, maxHealth:80 }; 
                            break;
                    }
                    if (enemy) { 
                        // DOUBLE CHECK: ensure health is a number
                        enemy.health = Number(enemy.health);
                        enemies.push(enemy); 
                        addParticles(s.x, s.y, '#ffaa66', 20); 
                    }
                    enemySpawners.splice(i,1);
                }
            }
        }

        // ----------  ENEMY AI ----------
        function updateEnemies() {
            let globalSpeedFactor = timeSlow ? 0.5 : 1.0;
            for (let i = enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                let dx = player.x - e.x, dy = player.y - e.y, dist = Math.hypot(dx, dy);
                if (dist > 1) {
                    if (e.behavior === 'chase' || e.behavior === 'boss') { 
                        e.vx = (dx/dist)*e.speed*globalSpeedFactor; e.vy = (dy/dist)*e.speed*globalSpeedFactor; 
                    }
                    else if (e.behavior === 'flee' && dist < 300) { 
                        e.vx = -(dx/dist)*e.speed*globalSpeedFactor; e.vy = -(dy/dist)*e.speed*globalSpeedFactor; 
                    }
                    else if (e.behavior === 'snipe') { e.vx *= 0.9; e.vy *= 0.9; }
                    else if (e.behavior === 'jump') { 
                        e.jumpTimer--; 
                        if (e.jumpTimer<=0 && dist<200) { 
                            e.vx=(dx/dist)*e.speed*2*globalSpeedFactor; e.vy=(dy/dist)*e.speed*2*globalSpeedFactor; 
                            e.jumpTimer=40+Math.random()*40; 
                        } else { e.vx*=0.9; e.vy*=0.9; } 
                    }
                }
                e.x += e.vx; e.y += e.vy;
                handleWallCollision(e, e.w, e.h);
                e.x = Math.max(20, Math.min(e.x, WORLD_SIZE - e.w - 20)); 
                e.y = Math.max(20, Math.min(e.y, WORLD_SIZE - e.h - 20));
                
                if (e.type.includes('boss') && e.health < e.maxHealth/2 && e.phase === 1) { 
                    e.phase=2; e.speed*=1.3; e.shootTimer/=1.5; 
                    addParticles(e.x+e.w/2, e.y+e.h/2, '#ff3333', 30); 
                }
                
                e.shootTimer--;
                if (e.shootTimer <= 0 && gameActive && playerHealth>0 && dist<600) {
                    let bdx = player.x - e.x, bdy = player.y - e.y, len = Math.hypot(bdx,bdy);
                    if (len>0) { 
                        bdx/=len; bdy/=len; 
                        enemyBullets.push({ x:e.x+e.w/2-6, y:e.y+e.h/2-3, w:12, h:6, vx:bdx*3.5, vy:bdy*3.5, life:80 }); 
                    }
                    e.shootTimer = e.type==='heavy'?150+Math.random()*150: e.type==='sniper'?200+Math.random()*150: e.type.includes('boss')?80+Math.random()*80: 100+Math.random()*120;
                }
                
                let inv = player.invincible > 0 || invincibleStar;
                if (!inv && gameActive && playerHealth>0 && !shieldActive) {
                    if (collides({x:player.x,y:player.y,w:PLAYER_WIDTH,h:PLAYER_HEIGHT}, {x:e.x,y:e.y,w:e.w,h:e.h})) {
                        playerHealth--; 
                        player.invincible=110; 
                        addParticles(player.x+PLAYER_WIDTH/2, player.y+PLAYER_HEIGHT/2, '#ff5555',15);
                        if (playerHealth<0) playerHealth=0; 
                        updateUI();
                    }
                }
            }
        }

        // ----------  BULLETS ‚Äì COMPLETELY REBUILT, NOW GUARANTEED TO KILL ----------
        function updateBullets() {
            // 1. Player bullets vs enemy bullets (parry)
            for (let i = bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                for (let j = enemyBullets.length-1; j>=0; j--) {
                    let eb = enemyBullets[j];
                    if (collides({x:b.x, y:b.y, w:b.w, h:b.h}, {x:eb.x, y:eb.y, w:eb.w, h:eb.h})) {
                        addParticles(b.x+16, b.y+16, '#ffff88', 12);
                        bullets.splice(i,1);
                        enemyBullets.splice(j,1);
                        break;
                    }
                }
            }

            // 2. Move bullets and store previous position
            for (let i = 0; i < bullets.length; i++) {
                let b = bullets[i];
                b.prevX = b.x;
                b.prevY = b.y;
                b.x += b.vx;
                b.y += b.vy;
                b.life--;
            }

            // 3. Collision detection with enemies (using AABB)
            for (let i = bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                
                // Remove if out of bounds or dead
                if (b.x < -100 || b.x > WORLD_SIZE+100 || b.y < -100 || b.y > WORLD_SIZE+100 || b.life <= 0) { 
                    bullets.splice(i,1); 
                    continue; 
                }

                // Wall collision
                let wallHit = false;
                for (let wall of walls) {
                    if (collides({x:b.x, y:b.y, w:b.w, h:b.h}, wall)) {
                        if (b.ricochetLeft > 0) {
                            // Simple bounce
                            let leftDist = b.x - wall.x, rightDist = (wall.x+wall.w) - (b.x+b.w);
                            let topDist = b.y - wall.y, bottomDist = (wall.y+wall.h) - (b.y+b.h);
                            if (Math.abs(leftDist) < Math.abs(rightDist)) b.vx = -b.vx; else b.vx = -b.vx;
                            if (Math.abs(topDist) < Math.abs(bottomDist)) b.vy = -b.vy; else b.vy = -b.vy;
                            b.ricochetLeft--;
                            wallHit = true;
                            break;
                        } else { 
                            bullets.splice(i,1); 
                            wallHit = true; 
                            break; 
                        }
                    }
                }
                if (wallHit) continue;

                // Homing
                if (b.homing && b.homing.health > 0) {
                    let dx = b.homing.x + b.homing.w/2 - (b.x + b.w/2);
                    let dy = b.homing.y + b.homing.h/2 - (b.y + b.h/2);
                    let len = Math.hypot(dx,dy); 
                    if (len>0) { 
                        b.vx += (dx/len)*b.homingStrength; 
                        b.vy += (dy/len)*b.homingStrength; 
                        let sp = Math.hypot(b.vx,b.vy); 
                        if(sp>7) { 
                            b.vx=(b.vx/sp)*7; 
                            b.vy=(b.vy/sp)*7; 
                        } 
                    }
                }

                // ENEMY COLLISION ‚Äì DIRECT AABB, NO FANCY STUFF
                for (let j = enemies.length-1; j>=0; j--) {
                    let e = enemies[j];
                    
                    // Simple AABB collision check
                    if (collides({x:b.x, y:b.y, w:b.w, h:b.h}, {x:e.x, y:e.y, w:e.w, h:e.h})) {
                        
                        // DAMAGE! Subtract health using numeric value
                        e.health -= b.damage;
                        
                        // Visual feedback ‚Äì red hit effect
                        addParticles(b.x + b.w/2, b.y + b.h/2, '#ff0000', 12);
                        
                        // Remove bullet if not piercing
                        if (b.piercing <= 0) {
                            bullets.splice(i,1);
                        } else {
                            b.piercing--;
                        }
                        
                        // Check if enemy died
                        if (e.health <= 0) {
                            score += e.points; 
                            if (score > highScore) { 
                                highScore = score; 
                                localStorage.setItem('commandoDeluxe', highScore); 
                            }
                            explosions.push({ x: e.x+e.w/2, y: e.y+e.h/2, life:22, radius:18 });
                            addParticles(e.x+e.w/2, e.y+e.h/2, '#ffaa00', 20);
                            
                            // Drop power-up (80% chance)
                            if (Math.random() < 0.8) {
                                let types = ['health','rapid','shield','spread','star','homing','piercing','speed','slow','damage','bomb','ricochet','regen','maxhealth'];
                                let type = types[Math.floor(Math.random() * types.length)];
                                pickups.push({ 
                                    x: e.x, y: e.y, w: 20, h: 20, 
                                    type: type, 
                                    vx: (Math.random()-0.5)*2, 
                                    vy: (Math.random()-0.5)*2, 
                                    life: 600 
                                });
                            }
                            enemies.splice(j,1);
                        }
                        
                        // If bullet was removed, break out of enemy loop
                        if (b.piercing <= 0 && i >= bullets.length) {
                            break;
                        }
                    }
                }
            }
        }

        // ----------  ENEMY BULLETS ----------
        function updateEnemyBullets() {
            for (let i = enemyBullets.length-1; i>=0; i--) {
                let eb = enemyBullets[i]; 
                eb.x += eb.vx; 
                eb.y += eb.vy; 
                eb.life--;
                if (eb.x<-100||eb.x>WORLD_SIZE+100||eb.y<-100||eb.y>WORLD_SIZE+100||eb.life<=0) { 
                    enemyBullets.splice(i,1); 
                    continue; 
                }
                for (let wall of walls) { 
                    if (collides({x:eb.x,y:eb.y,w:eb.w,h:eb.h}, wall)) { 
                        enemyBullets.splice(i,1); 
                        break; 
                    } 
                }
                if (i >= enemyBullets.length) continue;
                
                let inv = player.invincible > 0 || invincibleStar;
                if (!inv && gameActive && playerHealth>0 && !shieldActive) {
                    if (collides({x:player.x,y:player.y,w:PLAYER_WIDTH,h:PLAYER_HEIGHT}, {x:eb.x,y:eb.y,w:eb.w,h:eb.h})) {
                        playerHealth--; 
                        player.invincible=100; 
                        addParticles(eb.x, eb.y, '#ff5555',8); 
                        enemyBullets.splice(i,1);
                        if (playerHealth<0) playerHealth=0; 
                        updateUI();
                    }
                }
            }
        }

        // ----------  PICKUPS ----------
        function updatePickups() {
            for (let i = pickups.length-1; i>=0; i--) {
                let p = pickups[i]; 
                p.x += p.vx; 
                p.y += p.vy; 
                p.life--;
                if (p.life<=0 || p.x<-100||p.x>WORLD_SIZE+100||p.y<-100||p.y>WORLD_SIZE+100) { 
                    pickups.splice(i,1); 
                    continue; 
                }
                if (collides({x:player.x,y:player.y,w:PLAYER_WIDTH,h:PLAYER_HEIGHT}, {x:p.x,y:p.y,w:p.w,h:p.h})) {
                    addParticles(p.x, p.y, '#ffff66', 20);
                    if (p.type === 'health') playerHealth = Math.min(MAX_HEALTH, playerHealth + 2);
                    else if (p.type === 'rapid') { rapidFire = true; rapidTimer = 600; }
                    else if (p.type === 'shield') { shieldActive = true; shieldTimer = 600; }
                    else if (p.type === 'spread') { spreadShot = true; spreadTimer = 600; }
                    else if (p.type === 'star') { invincibleStar = true; starTimer = 500; }
                    else if (p.type === 'homing') { homingMissiles = true; homingTimer = 600; }
                    else if (p.type === 'piercing') { piercingShots = true; piercingTimer = 600; }
                    else if (p.type === 'speed') { speedBoost = true; speedTimer = 500; }
                    else if (p.type === 'slow') { timeSlow = true; slowTimer = 400; }
                    else if (p.type === 'damage') { damageBoost = true; damageTimer = 700; }
                    else if (p.type === 'bomb') { bombCharge = true; bombChargeTimer = 600; player.bombCooldown = Math.max(0, player.bombCooldown - 150); }
                    else if (p.type === 'ricochet') { ricochet = true; ricochetTimer = 600; }
                    else if (p.type === 'regen') { regen = true; regenTimer = 600; regenCounter = 0; }
                    else if (p.type === 'maxhealth') { 
                        if (MAX_HEALTH < 14) MAX_HEALTH += 2; 
                        playerHealth = Math.min(MAX_HEALTH, playerHealth + 2); 
                        maxHealthUp = true; 
                        maxHealthTimer = 10; 
                    }
                    pickups.splice(i,1);
                    updateUI();
                }
            }
        }

        // ----------  EFFECTS ----------
        function updateExplosions() { 
            for (let i=explosions.length-1;i>=0;i--) { 
                explosions[i].life-=1.5; 
                explosions[i].radius+=1.4; 
                if(explosions[i].life<=0) explosions.splice(i,1); 
            } 
        }
        
        function updateParticles() { 
            for (let i=particles.length-1;i>=0;i--) { 
                let p=particles[i]; 
                p.x+=p.vx; 
                p.y+=p.vy; 
                p.life-=2; 
                p.vx*=0.98; 
                p.vy*=0.98; 
                if(p.life<=0) particles.splice(i,1); 
            } 
        }
        
        function checkExit() {
            if (exitDoor && enemies.length === 0 && Math.hypot(player.x-exitDoor.x, player.y-exitDoor.y) < 50) {
                if (currentLevel < MAX_LEVEL) {
                    currentLevel++; 
                    let oldScore=score, oldHealth=playerHealth, oldHigh=highScore, oldMaxHealth=MAX_HEALTH;
                    buildLevel(currentLevel);
                    player.x=300; player.y=300; 
                    cameraX=player.x-VIEWPORT_W/2; cameraY=player.y-VIEWPORT_H/2;
                    cameraX=Math.max(0,Math.min(cameraX,WORLD_SIZE-VIEWPORT_W)); 
                    cameraY=Math.max(0,Math.min(cameraY,WORLD_SIZE-VIEWPORT_H));
                    
                    // Reset power-ups but keep health/score/maxhealth
                    rapidFire=false; rapidTimer=0; shieldActive=false; shieldTimer=0; 
                    spreadShot=false; spreadTimer=0; invincibleStar=false; starTimer=0;
                    homingMissiles=false; homingTimer=0; piercingShots=false; piercingTimer=0; 
                    speedBoost=false; speedTimer=0; timeSlow=false; slowTimer=0;
                    damageBoost=false; damageTimer=0; bombCharge=false; bombChargeTimer=0; 
                    ricochet=false; ricochetTimer=0; regen=false; regenTimer=0; regenCounter=0;
                    maxHealthUp=false; maxHealthTimer=0;
                    
                    enemies=[]; enemyBullets=[]; pickups=[];
                    score=oldScore; playerHealth=oldHealth; highScore=oldHigh; MAX_HEALTH=oldMaxHealth;
                    addParticles(player.x+PLAYER_WIDTH/2, player.y+PLAYER_HEIGHT/2, '#ffff00', 40); 
                    updateUI();
                } else { 
                    gameActive = false; 
                    victoryFlag = true; 
                    gameOver = false; 
                }
            }
        }

        // ----------  RENDERING ‚Äì GRIZZLE EFFECTS IN FULL GLORY ----------
        function drawWorld() {
            if (!ctx) return; 
            ctx.save(); 
            ctx.translate(-cameraX, -cameraY);
            
            // ----- THEMED BACKGROUND (grizzle) -----
            if (levelTheme === 'jungle') {
                ctx.fillStyle = '#1a4a3a'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.strokeStyle = '#3a6a4a'; ctx.lineWidth = 2;
                for (let i=0;i<60;i++) { 
                    ctx.beginPath(); 
                    ctx.moveTo(Math.random()*WORLD_SIZE, 0); 
                    ctx.lineTo(Math.random()*WORLD_SIZE, WORLD_SIZE); 
                    ctx.stroke(); 
                }
                for (let i=0;i<40;i++) { 
                    ctx.fillStyle = '#2a6a2a'; 
                    ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 12, 24); 
                }
            } else if (levelTheme === 'factory') {
                ctx.fillStyle = '#3a4a4a'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.strokeStyle = '#5a6a6a'; ctx.lineWidth = 1;
                for (let i=0;i<WORLD_SIZE;i+=50) { 
                    ctx.beginPath(); 
                    ctx.moveTo(i,0); 
                    ctx.lineTo(i,WORLD_SIZE); 
                    ctx.stroke(); 
                    ctx.beginPath(); 
                    ctx.moveTo(0,i); 
                    ctx.lineTo(WORLD_SIZE,i); 
                    ctx.stroke(); 
                }
                for (let i=0;i<80;i++) { 
                    ctx.fillStyle = '#6a7a7a'; 
                    ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 6, 2); 
                }
            } else if (levelTheme === 'alien') {
                ctx.fillStyle = '#2a2a5a'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.fillStyle = '#8a8aff'; 
                for (let i=0;i<300;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 3, 3);
                ctx.fillStyle = '#b0b0ff'; 
                for (let i=0;i<150;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 2, 2);
            } else if (levelTheme === 'ice') {
                ctx.fillStyle = '#a0d0e0'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.fillStyle = '#ffffff'; 
                for (let i=0;i<200;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 4, 4);
                ctx.fillStyle = '#c0e0f0'; 
                for (let i=0;i<150;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 2, 10);
            } else if (levelTheme === 'volcano') {
                ctx.fillStyle = '#4a2a2a'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.fillStyle = '#ff6a2a'; 
                for (let i=0;i<150;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 6, 2);
                ctx.fillStyle = '#ffaa4a'; 
                for (let i=0;i<100;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 4, 1);
            } else if (levelTheme === 'fortress') {
                ctx.fillStyle = '#2a2a3a'; ctx.fillRect(0,0,WORLD_SIZE,WORLD_SIZE);
                ctx.fillStyle = '#4a4a6a'; 
                for (let i=0;i<150;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 12, 6);
                ctx.fillStyle = '#6a6a8a'; 
                for (let i=0;i<100;i++) ctx.fillRect(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, 8, 4);
            }

            // ----- WALLS -----
            walls.forEach(w => { 
                ctx.fillStyle = '#5c4a34'; 
                ctx.fillRect(w.x, w.y, w.w, w.h); 
                ctx.fillStyle = '#ffffaa20'; 
                ctx.fillRect(w.x, w.y-2, w.w, 4); 
                ctx.fillStyle = '#00000030'; 
                ctx.fillRect(w.x+2, w.y+2, w.w, w.h); 
            });

            // ----- EXIT DOOR -----
            if (exitDoor) { 
                ctx.fillStyle = enemies.length===0?'#ffd966':'#ac8c5a'; 
                ctx.shadowBlur = enemies.length===0?20:0; 
                ctx.shadowColor = '#ffd966'; 
                ctx.fillRect(exitDoor.x, exitDoor.y, 40, 40); 
                ctx.shadowBlur = 0; 
            }

            // ----- ENEMIES -----
            enemies.forEach(e => { 
                ctx.fillStyle = e.type.includes('boss')?'#b34b4b':'#b35a4a'; 
                ctx.fillRect(e.x, e.y, e.w, e.h); 
                ctx.fillStyle = '#000'; 
                ctx.fillRect(e.x+4, e.y+4, 5,5); 
                ctx.fillRect(e.x+e.w-9, e.y+4, 5,5); 
                if(e.type.includes('boss')){ 
                    ctx.shadowBlur=15; 
                    ctx.shadowColor='#ff6a6a'; 
                    ctx.fillRect(e.x,e.y,e.w,e.h); 
                    ctx.shadowBlur=0; 
                } 
            });

            // ----- BULLETS ‚Äì 32x32 SQUARES -----
            bullets.forEach(b => { 
                ctx.fillStyle = '#ffd966'; 
                ctx.shadowBlur = 8; 
                ctx.shadowColor = '#ffaa00'; 
                ctx.fillRect(b.x, b.y, b.w, b.h); 
                ctx.shadowBlur = 0; 
            });
            
            enemyBullets.forEach(b => { 
                ctx.fillStyle = '#ff8c8c'; 
                ctx.shadowBlur = 6; 
                ctx.shadowColor = '#ff0000'; 
                ctx.fillRect(b.x, b.y, b.w, b.h); 
                ctx.shadowBlur = 0; 
            });

            // ----- PICKUPS -----
            pickups.forEach(p => { 
                ctx.shadowBlur = 12; 
                ctx.shadowColor = '#ffffaa'; 
                ctx.fillStyle = '#4caf7a'; 
                ctx.fillRect(p.x, p.y, p.w, p.h); 
                ctx.fillStyle = 'white'; 
                ctx.font = '20px monospace';
                let icon = '?'; 
                if (p.type==='health') icon='‚ù§Ô∏è'; 
                else if (p.type==='rapid') icon='‚ö°'; 
                else if (p.type==='shield') icon='üõ°Ô∏è'; 
                else if (p.type==='spread') icon='üåü'; 
                else if (p.type==='star') icon='‚ú®'; 
                else if (p.type==='homing') icon='üéØ'; 
                else if (p.type==='piercing') icon='üî•'; 
                else if (p.type==='speed') icon='üí®'; 
                else if (p.type==='slow') icon='‚è±Ô∏è'; 
                else if (p.type==='damage') icon='üí•'; 
                else if (p.type==='bomb') icon='üí£'; 
                else if (p.type==='ricochet') icon='‚Ü©Ô∏è'; 
                else if (p.type==='regen') icon='ü©∏'; 
                else if (p.type==='maxhealth') icon='üí™';
                ctx.fillText(icon, p.x, p.y+16); 
                ctx.shadowBlur = 0; 
            });

            // ----- EXPLOSIONS & PARTICLES -----
            explosions.forEach(ex => { 
                ctx.fillStyle = `rgba(255, 140, 30, ${ex.life/30})`; 
                ctx.beginPath(); 
                ctx.arc(ex.x, ex.y, ex.radius, 0, 2*Math.PI); 
                ctx.fill(); 
            });
            
            particles.forEach(p => { 
                ctx.fillStyle = p.color; 
                ctx.fillRect(p.x, p.y, p.size, p.size); 
            });

            // ----- PLAYER -----
            if (player.invincible % 8 < 4 || player.invincible === 0 || invincibleStar) {
                let px=player.x, py=player.y; 
                if (shieldActive) { 
                    ctx.shadowBlur=20; 
                    ctx.shadowColor='#7fb3d5'; 
                }
                ctx.fillStyle = invincibleStar?'#ffd966':'#3a7251'; 
                ctx.fillRect(px, py, PLAYER_WIDTH, PLAYER_HEIGHT);
                ctx.fillStyle = '#5a8f4c'; 
                ctx.fillRect(px+10, py-2, 24, 8);
                ctx.strokeStyle = '#414141'; 
                ctx.lineWidth = 8; 
                ctx.beginPath(); 
                ctx.moveTo(px+PLAYER_WIDTH/2, py+PLAYER_HEIGHT/2); 
                ctx.lineTo(px+PLAYER_WIDTH/2 + Math.cos(player.aimAngle)*30, py+PLAYER_HEIGHT/2 + Math.sin(player.aimAngle)*30); 
                ctx.stroke();
                ctx.fillStyle = '#2b543a'; 
                ctx.fillRect(px+8, py+PLAYER_HEIGHT-6, 6, 8); 
                ctx.fillRect(px+PLAYER_WIDTH-14, py+PLAYER_HEIGHT-6, 6, 8);
                ctx.shadowBlur = 0; 
                ctx.fillStyle = '#00000040'; 
                ctx.fillRect(px-2, py+PLAYER_HEIGHT-2, PLAYER_WIDTH+4, 8);
            }
            ctx.strokeStyle = '#ffffff80'; 
            ctx.lineWidth = 2; 
            ctx.beginPath(); 
            ctx.moveTo(player.x+PLAYER_WIDTH/2, player.y+PLAYER_HEIGHT/2); 
            ctx.lineTo(player.x+PLAYER_WIDTH/2 + Math.cos(player.aimAngle)*60, player.y+PLAYER_HEIGHT/2 + Math.sin(player.aimAngle)*60); 
            ctx.stroke();
            ctx.restore();
        }

        // ----------  GAME LOOP ----------
        function gameLoop() {
            if (gameActive) {
                updateCamera(); 
                checkSpawners(); 
                updatePlayer(); 
                updateBullets(); 
                updateEnemies(); 
                updateEnemyBullets(); 
                updatePickups(); 
                updateExplosions(); 
                updateParticles(); 
                checkExit();
                if (playerHealth <= 0) { 
                    gameActive = false; 
                    gameOver = true; 
                    victoryFlag = false; 
                } 
                updateUI();
            }
            drawWorld();
            
            // HUD power‚Äëup icons
            ctx.save(); 
            ctx.font = '20px "Courier New", monospace'; 
            ctx.fillStyle = '#fff'; 
            ctx.fillText('üí£ ' + Math.floor(player.bombCooldown/60), 20, 50);
            let x = 120;
            if (rapidFire) { ctx.fillText('‚ö°', x, 50); x+=40; } 
            if (spreadShot) { ctx.fillText('üåü', x, 50); x+=40; } 
            if (homingMissiles) { ctx.fillText('üéØ', x, 50); x+=40; } 
            if (piercingShots) { ctx.fillText('üî•', x, 50); x+=40; } 
            if (speedBoost) { ctx.fillText('üí®', x, 50); x+=40; } 
            if (timeSlow) { ctx.fillText('‚è±Ô∏è', x, 50); x+=40; } 
            if (damageBoost) { ctx.fillText('üí•', x, 50); x+=40; } 
            if (bombCharge) { ctx.fillText('üí£‚ö°', x, 50); x+=50; } 
            if (ricochet) { ctx.fillText('‚Ü©Ô∏è', x, 50); x+=40; } 
            if (regen) { ctx.fillText('ü©∏', x, 50); x+=40; }
            ctx.restore();
            
            if (!gameActive) {
                ctx.save(); 
                ctx.fillStyle = '#000000bb'; 
                ctx.fillRect(220, 190, 360, 90); 
                ctx.fillStyle = '#ffe98c'; 
                ctx.font = '36px "Courier New", monospace'; 
                ctx.textAlign = 'center';
                if (victoryFlag) ctx.fillText('üèÅ VICTORY!', 400, 245); 
                else if (gameOver) ctx.fillText('‚ùå GAME OVER', 400, 245); 
                else ctx.fillText('- PAUSE -', 400, 245);
                ctx.restore();
            }
            frame++; 
            animFrameId = requestAnimationFrame(gameLoop);
        }

        // ----------  CONTROLS ‚Äì responsive ----------
        function initAnalogStick() {
            const stick = document.getElementById('joystickHandle'), base = document.getElementById('joystickBase'), container = document.getElementById('joystickContainer');
            if (!stick || !base || !container) return;
            let active = false; const maxDist = 40;
            function handleStart(e) { e.preventDefault(); active = true; }
            function handleMove(e) {
                if (!active) return; e.preventDefault();
                let touch = e.touches ? e.touches[0] : e;
                let rect = base.getBoundingClientRect(), cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
                let dx = touch.clientX - cx, dy = touch.clientY - cy, dist = Math.hypot(dx, dy);
                if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; }
                stick.style.left = dx + 'px'; stick.style.top = dy + 'px';
                keys.left = dx < -5; keys.right = dx > 5; keys.up = dy < -5; keys.down = dy > 5;
            }
            function handleEnd(e) { 
                e.preventDefault(); 
                active = false; 
                stick.style.left = '0px'; 
                stick.style.top = '0px'; 
                keys.left = false; keys.right = false; keys.up = false; keys.down = false; 
            }
            container.addEventListener('touchstart', handleStart, { passive: false }); 
            container.addEventListener('touchmove', handleMove, { passive: false });
            container.addEventListener('touchend', handleEnd, { passive: false }); 
            container.addEventListener('touchcancel', handleEnd, { passive: false });
            container.addEventListener('mousedown', handleStart); 
            window.addEventListener('mousemove', handleMove); 
            window.addEventListener('mouseup', handleEnd);
        }
        
        function initTouchButtons() {
            const tf = document.getElementById('touchFire'), tb = document.getElementById('touchBomb');
            function setKey(k, s, e) { 
                if(e){ e.preventDefault(); e.stopPropagation(); } 
                keys[k] = s; 
            }
            if(tf) { 
                tf.addEventListener('touchstart', (e)=>setKey('fire',true,e), {passive:false}); 
                tf.addEventListener('touchend', (e)=>setKey('fire',false,e), {passive:false}); 
                tf.addEventListener('mousedown', (e)=>setKey('fire',true,e)); 
                tf.addEventListener('mouseup', (e)=>setKey('fire',false,e)); 
            }
            if(tb) { 
                tb.addEventListener('touchstart', (e)=>setKey('bomb',true,e), {passive:false}); 
                tb.addEventListener('touchend', (e)=>setKey('bomb',false,e), {passive:false}); 
                tb.addEventListener('mousedown', (e)=>setKey('bomb',true,e)); 
                tb.addEventListener('mouseup', (e)=>setKey('bomb',false,e)); 
            }
        }
        
        function initKeyboard() {
            window.addEventListener('keydown', (e) => { 
                if (!gameActive) return;
                switch(e.key) { 
                    case 'ArrowLeft': keys.left = true; e.preventDefault(); break; 
                    case 'ArrowRight': keys.right = true; e.preventDefault(); break; 
                    case 'ArrowUp': keys.up = true; e.preventDefault(); break; 
                    case 'ArrowDown': keys.down = true; e.preventDefault(); break; 
                    case 'z': case 'Z': keys.fire = true; e.preventDefault(); break; 
                    case 'x': case 'X': keys.bomb = true; e.preventDefault(); break; 
                }
            });
            window.addEventListener('keyup', (e) => {
                switch(e.key) { 
                    case 'ArrowLeft': keys.left = false; e.preventDefault(); break; 
                    case 'ArrowRight': keys.right = false; e.preventDefault(); break; 
                    case 'ArrowUp': keys.up = false; e.preventDefault(); break; 
                    case 'ArrowDown': keys.down = false; e.preventDefault(); break; 
                    case 'z': case 'Z': keys.fire = false; e.preventDefault(); break; 
                    case 'x': case 'X': keys.bomb = false; e.preventDefault(); break; 
                }
            });
        }

        // ----------  INIT ----------
        function init() { 
            resetGame(); 
            initAnalogStick(); 
            initTouchButtons(); 
            initKeyboard(); 
            const restartBtn = document.getElementById('restartButton'); 
            if(restartBtn) { 
                restartBtn.addEventListener('click', resetGame); 
                restartBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); resetGame(); }, {passive:false}); 
            } 
            drawWorld(); 
            if(animFrameId) cancelAnimationFrame(animFrameId); 
            animFrameId = requestAnimationFrame(gameLoop); 
        }
        
        window.addEventListener('load', init); 
        if(document.readyState==='complete'||document.readyState==='interactive') setTimeout(init,1); 
        else window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('beforeunload', ()=>cancelAnimationFrame(animFrameId));
    })();
</script>
</body>
</html>
