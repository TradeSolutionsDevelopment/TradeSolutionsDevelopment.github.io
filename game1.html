<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <title>8-bit COMMANDO ¬∑ GameBoy mobile ¬∑ fixed canvas</title>
    <meta name="description" content="Fullscreen GameBoy mode. D‚Äëpad left, AB right. Tactical enemies, 6 power‚Äëups, spread shot, star. Pixel perfect.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        html, body {
            width: 100%;
            height: 100%;
            background: #0a1a1f;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
            touch-action: pan-y;
        }
        .arcade-cabinet {
            background: #1c3840;
            padding: 15px 15px 20px;
            border-radius: 30px 30px 15px 15px;
            box-shadow: 0 15px 0 #0c1c22, 0 20px 30px rgba(0,0,0,0.8);
            border-bottom: 8px solid #2d5662;
            max-width: 1000px;
            width: 100%;
            height: auto;
            margin: auto;
            display: flex;
            flex-direction: column;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 6px solid #2e5665;
            border-radius: 16px;
            box-shadow: inset 0 0 0 4px #6d9eb0, 0 8px 0 #142f39;
            width: 100%;
            height: auto;
            aspect-ratio: 800 / 500;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            background: #10262e; /* fallback ‚Äì canvas will draw over */
        }
        .panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            color: #b9f3ff;
            text-shadow: 2px 2px 0 #0f2a30;
            background: #1f424b;
            padding: 8px 16px;
            border-radius: 40px;
            border-bottom: 6px solid #0e262c;
            font-size: clamp(14px, 4vw, 20px);
            font-weight: 900;
            letter-spacing: 2px;
            flex-wrap: wrap;
        }
        .scores {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .scores span {
            background: #10262e;
            padding: 4px 12px;
            border-radius: 30px;
            border-bottom: 4px solid #308595;
            color: #fdffb8;
            margin-left: 6px;
            font-size: clamp(14px, 4vw, 20px);
        }
        .btn {
            background: #cf4e5c;
            color: white;
            border: none;
            border-radius: 40px;
            padding: 8px 18px;
            font-size: clamp(16px, 4vw, 22px);
            font-weight: bold;
            border-bottom: 6px solid #822c36;
            cursor: pointer;
            transition: 0.06s;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 0 #4e1e24;
            letter-spacing: 2px;
        }
        .btn:active {
            background: #ec6a7a;
            border-bottom-width: 3px;
            transform: translateY(3px);
        }
        /* Desktop legend (hidden on mobile) */
        .legend {
            color: #b3ecff;
            font-size: 15px;
            display: flex;
            gap: 20px;
            background: #16353f;
            padding: 8px 16px;
            border-radius: 40px;
            border-bottom: 5px solid #0b1f24;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 10px;
        }
        .health {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .health span { font-size: 24px; }

        /* ----------  GAMEBOY TOUCH CONTROLS ‚Äì DPAD LEFT, AB RIGHT ---------- */
        .touch-controls {
            display: none;
            margin-top: 15px;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            padding: 10px 5px;
            background: #2b4b55;
            border-radius: 60px;
            border-bottom: 8px solid #16333a;
            touch-action: none;
        }
        .dpad {
            display: grid;
            grid-template-columns: 70px 70px 70px;
            grid-template-rows: 70px 70px;
            gap: 6px;
            background: #1f3a40;
            padding: 12px;
            border-radius: 40px;
            border-bottom: 6px solid #0f262c;
        }
        .dpad-btn {
            background: #3f5f68;
            border-radius: 16px;
            border-bottom: 6px solid #1e353b;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            color: #e3f2fd;
            text-shadow: 3px 3px 0 #142f39;
            box-shadow: inset 0 -2px 0 #2e4e57;
            cursor: pointer;
            user-select: none;
            aspect-ratio: 1 / 1;
            touch-action: none;
        }
        .dpad-btn:active {
            border-bottom-width: 2px;
            transform: translateY(4px);
            background: #527a86;
        }
        .ab-buttons {
            display: flex;
            gap: 20px;
            margin-right: 15px;
        }
        .ab {
            background: #9e4a5c;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border-bottom: 8px solid #632c38;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            color: white;
            text-shadow: 3px 3px 0 #3a1e24;
            box-shadow: inset 0 -4px 0 #753a46;
            cursor: pointer;
            touch-action: none;
        }
        .ab:active {
            border-bottom-width: 3px;
            transform: translateY(5px);
            background: #c05e72;
        }
        .fullscreen-toggle {
            background: #307080;
            padding: 12px 20px;
            border-radius: 40px;
            color: white;
            font-size: 24px;
            border-bottom: 6px solid #1a414f;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            touch-action: none;
            white-space: nowrap;
        }
        .fullscreen-toggle:active {
            border-bottom-width: 2px;
            transform: translateY(4px);
        }

        /* Show touch controls on narrow screens ‚Äì DPAD LEFT, AB RIGHT */
        @media (max-width: 900px) {
            .touch-controls {
                display: flex !important;
                flex-wrap: nowrap;
                justify-content: space-between;
            }
            .legend {
                display: none;
            }
            .dpad {
                grid-template-columns: 60px 60px 60px;
                grid-template-rows: 60px 60px;
            }
            .ab {
                width: 70px;
                height: 70px;
                font-size: 28px;
            }
        }

        /* Fullscreen */
        .arcade-cabinet:fullscreen {
            max-width: 100%;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            background: #0f1e24;
            border-radius: 0;
            padding: 10px;
        }
        .arcade-cabinet:fullscreen canvas {
            max-height: 60vh;
            width: auto;
            max-width: 95%;
        }
    </style>
</head>
<body>
<div class="arcade-cabinet" id="gameCabinet">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <div class="panel">
        <div class="scores">üéØ <span id="scoreDisplay">00000</span></div>
        <div class="scores">üèÜ <span id="highScoreDisplay">00000</span></div>
        <button class="btn" id="restartButton">‚Üª RESTART</button>
    </div>
    
    <!-- Desktop legend (hidden on mobile) -->
    <div class="legend">
        <span><i>‚Üê ‚Üí</i> MOVE</span>
        <span><i>‚Üë / SPACE</i> DOUBLE JUMP</span>
        <span><i>Z</i> FIRE  &nbsp; <i>X</i> BOMB</span>
        <div class="health">‚ù§Ô∏è <span id="healthDisplay">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span></div>
        <span id="levelDisplay">LVL 1</span>
    </div>

    <!-- ========== GAMEBOY TOUCH CONTROLS ‚Äì DPAD LEFT, AB RIGHT ========== -->
    <div class="touch-controls" id="touchControls">
        <!-- D‚Äëpad on LEFT -->
        <div class="dpad">
            <div></div>
            <div class="dpad-btn" id="touchUp">‚¨ÜÔ∏è</div>
            <div></div>
            <div class="dpad-btn" id="touchLeft">‚¨ÖÔ∏è</div>
            <div class="dpad-btn" id="touchDown">‚¨áÔ∏è</div>
            <div class="dpad-btn" id="touchRight">‚û°Ô∏è</div>
        </div>
        <!-- AB buttons on RIGHT -->
        <div class="ab-buttons">
            <div class="ab" id="touchFire">FIRE</div>
            <div class="ab" id="touchBomb">BOMB</div>
        </div>
        <!-- Fullscreen toggle (still on right) -->
        <div class="fullscreen-toggle" id="fullscreenBtn">üïπÔ∏è FULL</div>
    </div>
</div>

<script>
    (function(){
        'use strict';
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) { alert('Canvas not supported!'); return; }
        ctx.imageSmoothingEnabled = false;

        // ----------  WORLD & CAMERA ----------
        const WORLD_WIDTH = 2800;
        const VIEWPORT_W = 800, VIEWPORT_H = 500;
        const GROUND_Y = 440;
        let cameraX = 0;

        // ----------  GLOBAL STATE ----------
        let gameActive = true;
        let gameOver = false;
        let victoryFlag = false;
        let currentLevel = 1;
        const MAX_LEVEL = 3;
        let frame = 0;
        let animFrameId = null;

        // ----------  SCORE & HIGHSCORE ----------
        let score = 0;
        let highScore = localStorage.getItem('commandoElite') ? parseInt(localStorage.getItem('commandoElite')) : 0;
        let playerHealth = 6;
        const MAX_HEALTH = 6;

        // ----------  POWER-UPS ----------
        let rapidFire = false, rapidTimer = 0;
        let shieldActive = false, shieldTimer = 0;
        let spreadShot = false, spreadTimer = 0;
        let invincibleStar = false, starTimer = 0;

        // ----------  PLAYER PHYSICS ----------
        const PLAYER_WIDTH = 22, PLAYER_HEIGHT = 28;
        const GRAVITY = 0.7;
        const JUMP_FORCE = -12.2;
        const MOVE_SPEED = 4.6;
        let player = {
            x: 200, y: GROUND_Y - PLAYER_HEIGHT,
            vx: 0, vy: 0,
            onGround: false,
            doubleJumpUsed: false,
            coyoteTime: 0,
            jumpBuffer: 0,
            facing: 1,
            walkCycle: 0,
            shootTimer: 0,
            invincible: 0,
            bombCooldown: 0,
        };

        // ----------  LEVEL DESIGN ----------
        let platforms = [];
        let enemySpawners = [];
        let exitDoor = null;
        let levelName = "";

        // ----------  DYNAMIC ENTITIES ----------
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let explosions = [];
        let pickups = [];
        let dustEffects = [];
        let sparks = [];
        let screenShake = 0;

        // ----------  KEYBOARD STATE (shared with touch) ----------
        const keys = { left: false, right: false, jump: false, fire: false, bomb: false, down: false };

        // ----------  LEVEL DEFINITIONS (COMPLETE) ----------
        function buildLevel(level) {
            platforms = []; enemySpawners = []; exitDoor = null;
            if (level === 1) {
                levelName = "FORGOTTEN JUNGLE";
                platforms = [
                    { x: 400, y: 360, w: 100, h: 12 }, { x: 620, y: 300, w: 80, h: 12 },
                    { x: 880, y: 340, w: 90, h: 12 }, { x: 1150, y: 280, w: 100, h: 12 },
                    { x: 1450, y: 320, w: 90, h: 12 }, { x: 1750, y: 260, w: 110, h: 12 },
                    { x: 2100, y: 380, w: 80, h: 12 }, { x: 2400, y: 300, w: 120, h: 12 }
                ];
                enemySpawners = [
                    { x: 550, type: 'infantry', side: 'right', behavior: 'flank' },
                    { x: 900, type: 'drone', side: 'left', behavior: 'swoop' },
                    { x: 1300, type: 'sniper', side: 'right', behavior: 'aim' },
                    { x: 1800, type: 'heavy', side: 'right', behavior: 'block' },
                    { x: 2200, type: 'jumper', side: 'left', behavior: 'leap' }
                ];
                exitDoor = { x: 2650, y: GROUND_Y - 48 };
            } else if (level === 2) {
                levelName = "MACHINE COMPLEX";
                platforms = [
                    { x: 380, y: 300, w: 100, h: 12 }, { x: 600, y: 240, w: 80, h: 12 },
                    { x: 820, y: 360, w: 90, h: 12 }, { x: 1080, y: 200, w: 100, h: 12 },
                    { x: 1350, y: 320, w: 90, h: 12 }, { x: 1650, y: 260, w: 110, h: 12 },
                    { x: 2000, y: 380, w: 80, h: 12 }, { x: 2300, y: 220, w: 120, h: 12 }
                ];
                enemySpawners = [
                    { x: 500, type: 'heavy', side: 'right', behavior: 'block' },
                    { x: 750, type: 'sniper', side: 'left', behavior: 'aim' },
                    { x: 1100, type: 'drone', side: 'right', behavior: 'swoop' },
                    { x: 1500, type: 'jumper', side: 'left', behavior: 'leap' },
                    { x: 1900, type: 'infantry', side: 'right', behavior: 'flank' },
                    { x: 2350, type: 'boss_lieutenant', side: 'right', behavior: 'command' }
                ];
                exitDoor = { x: 2700, y: GROUND_Y - 48 };
            } else if (level === 3) {
                levelName = "HELL HANGAR";
                platforms = [
                    { x: 420, y: 340, w: 120, h: 12 }, { x: 680, y: 260, w: 100, h: 12 },
                    { x: 950, y: 200, w: 100, h: 12 }, { x: 1250, y: 320, w: 90, h: 12 },
                    { x: 1580, y: 260, w: 110, h: 12 }, { x: 1920, y: 380, w: 80, h: 12 },
                    { x: 2250, y: 220, w: 120, h: 12 }
                ];
                enemySpawners = [
                    { x: 550, type: 'heavy', side: 'right', behavior: 'block' },
                    { x: 800, type: 'sniper', side: 'left', behavior: 'aim' },
                    { x: 1100, type: 'drone', side: 'right', behavior: 'swoop' },
                    { x: 1450, type: 'jumper', side: 'left', behavior: 'leap' },
                    { x: 1800, type: 'infantry', side: 'right', behavior: 'flank' },
                    { x: 2200, type: 'boss', side: 'right', behavior: 'final' }
                ];
                exitDoor = { x: 2650, y: GROUND_Y - 48 };
            }
        }

        // ----------  RESET GAME ----------
        function resetGame() {
            gameActive = true; gameOver = false; victoryFlag = false; currentLevel = 1;
            score = 0; playerHealth = MAX_HEALTH;
            rapidFire = false; rapidTimer = 0; shieldActive = false; shieldTimer = 0;
            spreadShot = false; spreadTimer = 0; invincibleStar = false; starTimer = 0;
            player = {
                x: 200, y: GROUND_Y - PLAYER_HEIGHT, vx: 0, vy: 0, onGround: false,
                doubleJumpUsed: false, coyoteTime: 0, jumpBuffer: 0, facing: 1,
                walkCycle: 0, shootTimer: 0, invincible: 0, bombCooldown: 0
            };
            bullets = []; enemies = []; enemyBullets = []; explosions = []; pickups = [];
            dustEffects = []; sparks = []; screenShake = 0;
            buildLevel(currentLevel); cameraX = 0;
            // reset keys
            keys.left = false; keys.right = false; keys.jump = false; keys.fire = false; keys.bomb = false; keys.down = false;
            updateUI();
        }

        // ----------  UI ----------
        function updateUI() {
            let scr = String(Math.floor(score)).padStart(5, '0');
            document.getElementById('scoreDisplay').innerText = scr;
            let hscr = String(highScore).padStart(5, '0');
            document.getElementById('highScoreDisplay').innerText = hscr;
            let healthBar = '';
            for (let i=0; i<playerHealth; i++) healthBar += '‚ñà';
            document.getElementById('healthDisplay').innerText = healthBar.padEnd(6, '‚ñë');
            document.getElementById('levelDisplay').innerText = levelName;
        }

        // ----------  COLLISION ----------
        function collides(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        }

        // ----------  SCREEN SHAKE ----------
        function addShake(amount) { screenShake = Math.min(screenShake + amount, 12); }

        // ----------  CAMERA ----------
        function updateCamera() {
            let targetX = player.x + PLAYER_WIDTH/2 - VIEWPORT_W/2;
            targetX = Math.max(0, Math.min(targetX, WORLD_WIDTH - VIEWPORT_W));
            cameraX += (targetX - cameraX) * 0.12;
            if (screenShake > 0) screenShake *= 0.8; else screenShake = 0;
        }

        // ----------  DUST & SPARKS ----------
        function addDust(x, y) { dustEffects.push({ x, y, life: 12 }); }
        function addSparks(x, y) { sparks.push({ x, y, life: 10 }); }

        // ----------  PLAYER UPDATE (COMPLETE) ----------
        function updatePlayer() {
            if (!gameActive) return;
            if (playerHealth <= 0) { gameActive = false; gameOver = true; victoryFlag = false; return; }

            if (rapidTimer > 0) rapidTimer--; else rapidFire = false;
            if (shieldTimer > 0) shieldTimer--; else shieldActive = false;
            if (spreadTimer > 0) spreadTimer--; else spreadShot = false;
            if (starTimer > 0) starTimer--; else invincibleStar = false;

            // horizontal movement
            let accel = 0;
            if (keys.left) accel -= 1;
            if (keys.right) accel += 1;
            player.vx = accel * MOVE_SPEED;
            player.x += player.vx;
            if (player.x < 20) player.x = 20;
            if (player.x + PLAYER_WIDTH > WORLD_WIDTH - 20) player.x = WORLD_WIDTH - PLAYER_WIDTH - 20;

            // coyote time
            if (player.onGround) { player.coyoteTime = 8; player.doubleJumpUsed = false; }
            else player.coyoteTime--;
            if (player.jumpBuffer > 0) player.jumpBuffer--;

            // jump logic
            let canJump = (player.onGround || player.coyoteTime > 0) && !player.doubleJumpUsed;
            let canDoubleJump = !player.onGround && !player.doubleJumpUsed && player.coyoteTime <= 0;
            if (player.jumpBuffer > 0) {
                if (canJump) {
                    player.vy = JUMP_FORCE;
                    player.onGround = false;
                    player.coyoteTime = 0;
                    player.jumpBuffer = 0;
                    addDust(player.x + PLAYER_WIDTH/2, player.y + PLAYER_HEIGHT);
                } else if (canDoubleJump) {
                    player.vy = JUMP_FORCE * 0.9;
                    player.doubleJumpUsed = true;
                    player.jumpBuffer = 0;
                    addDust(player.x + PLAYER_WIDTH/2, player.y + PLAYER_HEIGHT);
                }
            }

            // gravity
            player.vy += GRAVITY;
            player.y += player.vy;

            // ground collision
            player.onGround = false;
            if (player.y + PLAYER_HEIGHT > GROUND_Y) {
                player.y = GROUND_Y - PLAYER_HEIGHT;
                player.vy = 0;
                player.onGround = true;
                player.doubleJumpUsed = false;
                addDust(player.x + PLAYER_WIDTH/2, player.y + PLAYER_HEIGHT);
            }

            // platform collisions
            for (let pl of platforms) {
                if (player.vy >= 0) {
                    let bottom = player.y + PLAYER_HEIGHT;
                    let prevBottom = bottom - player.vy;
                    if (prevBottom <= pl.y && bottom >= pl.y &&
                        player.x + PLAYER_WIDTH > pl.x && player.x < pl.x + pl.w) {
                        player.y = pl.y - PLAYER_HEIGHT;
                        player.vy = 0;
                        player.onGround = true;
                        player.doubleJumpUsed = false;
                        addDust(player.x + PLAYER_WIDTH/2, player.y + PLAYER_HEIGHT);
                    }
                }
            }
            if (player.y < 30) player.y = 30;

            // facing & walk cycle
            if (player.vx > 0.2) player.facing = 1;
            else if (player.vx < -0.2) player.facing = -1;
            if (Math.abs(player.vx) > 0.5 && player.onGround) {
                player.walkCycle = (player.walkCycle + 0.25) % 4;
            } else player.walkCycle = 0;

            // shooting
            if (keys.fire && gameActive) {
                let fireRate = rapidFire ? 5 : 14;
                if (player.shootTimer <= 0) {
                    if (spreadShot) {
                        bullets.push({ x: player.facing === 1 ? player.x + PLAYER_WIDTH - 2 : player.x - 16, y: player.y + PLAYER_HEIGHT/2 - 6, w: 16, h: 6, vx: player.facing * 10, vy: -2.5 });
                        bullets.push({ x: player.facing === 1 ? player.x + PLAYER_WIDTH - 2 : player.x - 16, y: player.y + PLAYER_HEIGHT/2 - 3, w: 16, h: 6, vx: player.facing * 11, vy: 0 });
                        bullets.push({ x: player.facing === 1 ? player.x + PLAYER_WIDTH - 2 : player.x - 16, y: player.y + PLAYER_HEIGHT/2, w: 16, h: 6, vx: player.facing * 10, vy: 2.5 });
                    } else {
                        bullets.push({ x: player.facing === 1 ? player.x + PLAYER_WIDTH - 2 : player.x - 16, y: player.y + PLAYER_HEIGHT/2 - 3, w: 18, h: 6, vx: player.facing * 11, vy: 0 });
                    }
                    player.shootTimer = fireRate;
                }
            }
            if (player.shootTimer > 0) player.shootTimer--;

            // bomb
            if (keys.bomb && player.bombCooldown <= 0 && gameActive) {
                addShake(8);
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let e = enemies[i];
                    if (Math.abs(e.x - player.x) < 500) {
                        explosions.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 24, radius: 16 });
                        score += e.points;
                        addSparks(e.x + e.w/2, e.y + e.h/2);
                        enemies.splice(i, 1);
                    }
                }
                player.bombCooldown = 300;
            }
            if (player.bombCooldown > 0) player.bombCooldown--;
            if (player.invincible > 0) player.invincible--;
            if (invincibleStar) player.invincible = Math.max(player.invincible, 2);
        }

        // ----------  ENEMY SPAWN (COMPLETE) ----------
        function checkSpawners() {
            for (let i = enemySpawners.length - 1; i >= 0; i--) {
                let s = enemySpawners[i];
                if (player.x > s.x - 300 && player.x < s.x + 100) {
                    let side = s.side;
                    let xPos = side === 'right' ? WORLD_WIDTH - 60 : 60;
                    let yPos = GROUND_Y - 32;
                    let enemy = null;
                    switch (s.type) {
                        case 'infantry':
                            enemy = {
                                x: xPos, y: GROUND_Y - 32, w: 26, h: 30,
                                vx: side === 'right' ? -2.0 : 2.0, health: 1, points: 30,
                                type: 'infantry', behavior: s.behavior, frame: 0,
                                shootTimer: 40 + Math.random() * 20, patrolDir: side === 'right' ? -1 : 1
                            }; break;
                        case 'heavy':
                            enemy = {
                                x: xPos, y: GROUND_Y - 36, w: 32, h: 34,
                                vx: side === 'right' ? -1.1 : 1.1, health: 5, points: 100,
                                type: 'heavy', behavior: s.behavior, frame: 0, shootTimer: 30
                            }; break;
                        case 'drone':
                            yPos = 200 + Math.random() * 180;
                            enemy = {
                                x: xPos, y: yPos, w: 24, h: 20,
                                vx: side === 'right' ? -2.8 : 2.8, health: 1, points: 40,
                                type: 'drone', behavior: s.behavior, frame: 0, shootTimer: 50, swoopTimer: 0
                            }; break;
                        case 'sniper':
                            enemy = {
                                x: xPos, y: GROUND_Y - 36, w: 24, h: 30,
                                vx: side === 'right' ? -0.8 : 0.8, health: 2, points: 80,
                                type: 'sniper', behavior: s.behavior, frame: 0, shootTimer: 80, aimTimer: 0
                            }; break;
                        case 'jumper':
                            enemy = {
                                x: xPos, y: GROUND_Y - 32, w: 24, h: 28,
                                vx: side === 'right' ? -2.2 : 2.2, health: 2, points: 70,
                                type: 'jumper', behavior: s.behavior, frame: 0, shootTimer: 60, jumpTimer: 20
                            }; break;
                        case 'boss_lieutenant':
                            enemy = {
                                x: WORLD_WIDTH - 100, y: GROUND_Y - 48, w: 48, h: 48,
                                vx: -0.8, health: 15, points: 300, type: 'boss_lieutenant',
                                behavior: s.behavior, frame: 0, shootTimer: 25, phase: 1
                            }; break;
                        case 'boss':
                            enemy = {
                                x: WORLD_WIDTH - 120, y: GROUND_Y - 60, w: 60, h: 60,
                                vx: -0.6, health: 35, points: 800, type: 'boss',
                                behavior: s.behavior, frame: 0, shootTimer: 18, phase: 1
                            }; break;
                    }
                    if (enemy) enemies.push(enemy);
                    enemySpawners.splice(i, 1);
                }
            }
        }

        // ----------  ENEMY UPDATE (COMPLETE) ----------
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                e.x += e.vx;
                e.frame = (e.frame + 0.15) % 4;
                if (e.x + e.w < -150 || e.x > WORLD_WIDTH + 150) { enemies.splice(i, 1); continue; }

                // Special behaviors
                if (e.type === 'drone' && e.behavior === 'swoop') {
                    e.y += Math.sin(frame * 0.1) * 0.7;
                }
                if (e.type === 'jumper' && e.behavior === 'leap') {
                    e.jumpTimer--;
                    if (e.jumpTimer <= 0 && Math.abs(e.x - player.x) < 200 && e.y + e.h >= GROUND_Y - 5) {
                        e.vy = JUMP_FORCE * 0.8;
                        e.jumpTimer = 50 + Math.random() * 40;
                    }
                    e.y += e.vy || 0;
                    e.vy = (e.vy || 0) + GRAVITY * 0.5;
                    if (e.y + e.h > GROUND_Y) { e.y = GROUND_Y - e.h; e.vy = 0; }
                }
                if (e.type === 'sniper' && e.behavior === 'aim') {
                    e.vx = 0;
                    e.shootTimer = 40;
                }
                if (e.type === 'infantry' && e.behavior === 'flank') {
                    if (player.x > e.x) e.vx = 1.2; else e.vx = -1.2;
                }

                // shooting
                e.shootTimer--;
                if (e.shootTimer <= 0 && gameActive && playerHealth > 0 && Math.abs(e.x - player.x) < 600) {
                    let bulletVX = e.x > player.x ? -5.5 : 5.5;
                    if (e.type === 'drone') bulletVX *= 1.3;
                    if (e.type === 'sniper') bulletVX *= 1.5;
                    enemyBullets.push({
                        x: e.x + (bulletVX > 0 ? e.w : -8), y: e.y + e.h/2 - 3,
                        w: 10, h: 5, vx: bulletVX, vy: 0
                    });
                    e.shootTimer = e.type === 'heavy' ? 55 : (e.type === 'sniper' ? 70 :
                        (e.type === 'boss' || e.type === 'boss_lieutenant' ? 22 : 45));
                }

                // collision with player
                let inv = player.invincible > 0 || invincibleStar;
                if (!inv && gameActive && playerHealth > 0 && !shieldActive) {
                    if (collides({ x: player.x, y: player.y, w: PLAYER_WIDTH, h: PLAYER_HEIGHT },
                                 { x: e.x, y: e.y, w: e.w, h: e.h })) {
                        let dmg = (e.type === 'heavy' || e.type === 'boss' || e.type === 'boss_lieutenant') ? 2 : 1;
                        playerHealth -= dmg;
                        player.invincible = 70;
                        addShake(4);
                        if (playerHealth < 0) playerHealth = 0;
                        updateUI();
                    }
                }
            }
        }

        // ----------  BULLETS (COMPLETE) ----------
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.x += b.vx;
                b.y += b.vy || 0;
                if (b.x > WORLD_WIDTH + 150 || b.x < -150) { bullets.splice(i, 1); continue; }
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (collides({ x: b.x, y: b.y, w: b.w, h: b.h },
                                 { x: e.x, y: e.y, w: e.w, h: e.h })) {
                        bullets.splice(i, 1);
                        e.health -= 1;
                        addSparks(e.x + e.w/2, e.y + e.h/2);
                        if (e.health <= 0) {
                            score += e.points;
                            if (score > highScore) { highScore = score; localStorage.setItem('commandoElite', highScore); }
                            explosions.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 20, radius: 14 });
                            addShake(3);
                            if (Math.random() < 0.3) {
                                let types = ['health', 'rapid', 'shield', 'spread', 'star'];
                                let type = types[Math.floor(Math.random() * types.length)];
                                pickups.push({ x: e.x, y: e.y, w: 16, h: 16, type: type, vx: -1, life: 500 });
                            }
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
            }
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let eb = enemyBullets[i];
                eb.x += eb.vx;
                if (eb.x < -150 || eb.x > WORLD_WIDTH + 150) { enemyBullets.splice(i, 1); continue; }
                let inv = player.invincible > 0 || invincibleStar;
                if (!inv && gameActive && playerHealth > 0 && !shieldActive) {
                    if (collides({ x: player.x, y: player.y, w: PLAYER_WIDTH, h: PLAYER_HEIGHT },
                                 { x: eb.x, y: eb.y, w: eb.w, h: eb.h })) {
                        playerHealth -= 1;
                        player.invincible = 50;
                        addShake(3);
                        enemyBullets.splice(i, 1);
                        if (playerHealth < 0) playerHealth = 0;
                        updateUI();
                    }
                }
            }
        }

        // ----------  PICKUPS ----------
        function updatePickups() {
            for (let i = pickups.length - 1; i >= 0; i--) {
                let p = pickups[i];
                p.x += p.vx;
                p.life--;
                if (p.life <= 0 || p.x < -100) { pickups.splice(i, 1); continue; }
                if (collides({ x: player.x, y: player.y, w: PLAYER_WIDTH, h: PLAYER_HEIGHT },
                             { x: p.x, y: p.y, w: p.w, h: p.h })) {
                    if (p.type === 'health') playerHealth = Math.min(MAX_HEALTH, playerHealth + 2);
                    else if (p.type === 'rapid') { rapidFire = true; rapidTimer = 600; }
                    else if (p.type === 'shield') { shieldActive = true; shieldTimer = 600; }
                    else if (p.type === 'spread') { spreadShot = true; spreadTimer = 600; }
                    else if (p.type === 'star') { invincibleStar = true; starTimer = 500; }
                    pickups.splice(i, 1);
                    updateUI();
                }
            }
        }

        // ----------  EFFECTS ----------
        function updateDust() {
            for (let i = dustEffects.length - 1; i >= 0; i--) {
                dustEffects[i].life -= 1.2;
                if (dustEffects[i].life <= 0) dustEffects.splice(i, 1);
            }
        }
        function updateSparks() {
            for (let i = sparks.length - 1; i >= 0; i--) {
                sparks[i].life -= 1.5;
                if (sparks[i].life <= 0) sparks.splice(i, 1);
            }
        }
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                let ex = explosions[i];
                ex.life -= 1.5;
                ex.radius += 1.4;
                if (ex.life <= 0) explosions.splice(i, 1);
            }
        }

        // ----------  EXIT ‚Äì safe only when no enemies ----------
        function checkExit() {
            if (exitDoor && player.x > exitDoor.x - 40 && enemies.length === 0) {
                if (currentLevel < MAX_LEVEL) {
                    currentLevel++;
                    buildLevel(currentLevel);
                    player.x = 200; player.y = GROUND_Y - PLAYER_HEIGHT; cameraX = 0;
                    rapidFire = false; rapidTimer = 0; shieldActive = false; shieldTimer = 0;
                    spreadShot = false; spreadTimer = 0; invincibleStar = false; starTimer = 0;
                    enemies = []; enemyBullets = []; pickups = [];
                    updateUI();
                } else {
                    gameActive = false; gameOver = false; victoryFlag = true;
                }
            }
        }

        // ----------  RENDERING (COMPLETE) ----------
        function drawWorld() {
            ctx.save();
            if (screenShake > 0.5) {
                let sx = (Math.random() * 2 - 1) * screenShake;
                let sy = (Math.random() * 2 - 1) * screenShake;
                ctx.translate(sx, sy);
            }
            ctx.clearRect(0, 0, VIEWPORT_W, VIEWPORT_H);
            let bgOffset = cameraX * 0.2;
            ctx.fillStyle = '#0f3340'; ctx.fillRect(0, 0, VIEWPORT_W, 120);
            ctx.fillStyle = '#1f4f5a'; ctx.fillRect(0, 120, VIEWPORT_W, 70);
            ctx.fillStyle = '#2f6b75'; ctx.fillRect(0, 190, VIEWPORT_W, 60);
            ctx.fillStyle = '#48a5b0';
            for (let i = 0; i < 6; i++) { let x = (i * 180 - bgOffset) % 1000 - 100; ctx.fillRect(x, 200, 4, 60); }
            ctx.fillStyle = '#2a6b4a';
            for (let i = 0; i < 5; i++) {
                let x = (i * 220 - bgOffset * 0.6) % 900 - 100;
                ctx.beginPath(); ctx.moveTo(x, 310); ctx.quadraticCurveTo(x + 80, 220, x + 160, 310); ctx.fill();
            }
            ctx.fillStyle = '#4b6a3b'; ctx.fillRect(0, GROUND_Y - 6, VIEWPORT_W, 20);
            ctx.fillStyle = '#6d8f4d'; ctx.fillRect(0, GROUND_Y - 2, VIEWPORT_W, 8);
            platforms.forEach(p => {
                let sx = p.x - cameraX;
                if (sx + p.w > 0 && sx < VIEWPORT_W) {
                    ctx.fillStyle = '#5c4934'; ctx.fillRect(sx, p.y, p.w, p.h);
                    ctx.fillStyle = '#846b4a'; ctx.fillRect(sx + 2, p.y - 2, p.w - 4, 5);
                }
            });
            if (exitDoor) {
                let sx = exitDoor.x - cameraX;
                ctx.fillStyle = enemies.length === 0 ? '#f7d44a' : '#ac8c5a';
                if (enemies.length === 0) { ctx.shadowBlur = 12; ctx.shadowColor = '#ffd966'; }
                ctx.fillRect(sx, exitDoor.y, 30, 48);
                ctx.fillStyle = '#c9ae74'; ctx.fillRect(sx + 8, exitDoor.y - 8, 14, 12);
                ctx.shadowBlur = 0;
            }
            enemies.forEach(e => {
                let sx = e.x - cameraX;
                if (sx + e.w > 0 && sx < VIEWPORT_W) {
                    if (e.type === 'infantry') ctx.fillStyle = '#9d4e3a';
                    else if (e.type === 'heavy') ctx.fillStyle = '#6a4e4e';
                    else if (e.type === 'drone') ctx.fillStyle = '#467c7c';
                    else if (e.type === 'sniper') ctx.fillStyle = '#7a5c3c';
                    else if (e.type === 'jumper') ctx.fillStyle = '#b3763a';
                    else if (e.type.includes('boss')) ctx.fillStyle = '#b34b4b';
                    ctx.fillRect(sx, e.y, e.w, e.h);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(sx + 4, e.y + 6, 4, 4);
                    ctx.fillRect(sx + e.w - 8, e.y + 6, 4, 4);
                }
            });
            bullets.forEach(b => { let sx = b.x - cameraX; ctx.fillStyle = '#ffd966'; ctx.fillRect(sx, b.y, b.w, b.h); });
            enemyBullets.forEach(b => { let sx = b.x - cameraX; ctx.fillStyle = '#ff7474'; ctx.fillRect(sx, b.y, b.w, b.h); });
            pickups.forEach(p => {
                let sx = p.x - cameraX;
                ctx.fillStyle = '#4caf7a'; ctx.fillRect(sx, p.y, p.w, p.h);
                ctx.fillStyle = 'white'; ctx.font = '16px monospace';
                if (p.type === 'health') ctx.fillText('‚ù§Ô∏è', sx, p.y + 14);
                else if (p.type === 'rapid') ctx.fillText('‚ö°', sx, p.y + 14);
                else if (p.type === 'shield') ctx.fillText('üõ°Ô∏è', sx, p.y + 14);
                else if (p.type === 'spread') ctx.fillText('üåü', sx, p.y + 14);
                else if (p.type === 'star') ctx.fillText('‚ú®', sx, p.y + 14);
            });
            explosions.forEach(ex => {
                let sx = ex.x - cameraX;
                ctx.fillStyle = `rgba(255, 140, 30, ${ex.life / 30})`;
                ctx.beginPath(); ctx.arc(sx, ex.y, ex.radius, 0, 2 * Math.PI); ctx.fill();
            });
            dustEffects.forEach(d => { let sx = d.x - cameraX; ctx.fillStyle = `rgba(220,200,120,${d.life / 15})`; ctx.fillRect(sx - 2, d.y - 2, 6, 4); });
            sparks.forEach(s => { let sx = s.x - cameraX; ctx.fillStyle = '#ffaa66'; ctx.fillRect(sx, s.y, 3, 3); });
            if (player.invincible % 8 < 4 || player.invincible === 0 || invincibleStar) {
                let px = player.x - cameraX, py = player.y;
                ctx.fillStyle = shieldActive ? '#7fb3d5' : (invincibleStar ? '#ffd966' : '#3a7251');
                ctx.fillRect(px + 2, py + 2, 20, 22);
                ctx.fillStyle = '#5a8f4c'; ctx.fillRect(px + 6, py - 2, 12, 10);
                ctx.fillStyle = '#ab8b3b'; ctx.fillRect(player.facing === 1 ? px + 16 : px, py, 8, 6);
                ctx.fillStyle = '#414141';
                if (player.facing === 1) ctx.fillRect(px + 20, py + 10, 14, 4);
                else ctx.fillRect(px - 10, py + 10, 14, 4);
                if (!player.onGround && !player.doubleJumpUsed) {
                    ctx.fillStyle = '#ffe082';
                    ctx.fillRect(px - 2, py - 4, 4, 6);
                    ctx.fillRect(px + PLAYER_WIDTH - 2, py - 4, 4, 6);
                }
            }
            if (frame % 120 < 60 && gameActive) {
                ctx.font = 'bold 22px "Courier New", monospace';
                ctx.fillStyle = '#ffe082';
                ctx.shadowBlur = 8; ctx.shadowColor = 'black';
                ctx.fillText(levelName, 40, 80);
                ctx.shadowBlur = 0;
            }
            ctx.restore();
        }

        // ----------  GAME LOOP ----------
        function gameLoop() {
            if (gameActive) {
                updateCamera();
                checkSpawners();
                updatePlayer();
                updateBullets();
                updateEnemies();
                updateEnemyBullets();
                updatePickups();
                updateExplosions();
                updateDust();
                updateSparks();
                checkExit();
                if (playerHealth <= 0) { gameActive = false; gameOver = true; victoryFlag = false; }
                updateUI();
            }
            drawWorld();
            if (!gameActive) {
                ctx.fillStyle = '#000000bb';
                ctx.fillRect(220, 190, 360, 90);
                ctx.fillStyle = '#ffe98c';
                ctx.font = '36px "Courier New", monospace';
                ctx.textAlign = 'center';
                if (victoryFlag) ctx.fillText('üèÅ VICTORY!', 400, 245);
                else if (gameOver) ctx.fillText('‚ùå GAME OVER', 400, 245);
                else ctx.fillText('- PAUSE -', 400, 245);
            }
            frame++;
            animFrameId = requestAnimationFrame(gameLoop);
        }

        // ----------  TOUCH CONTROLS ‚Äì HARDENED, DPAD LEFT, AB RIGHT ----------
        function initTouchControls() {
            const touchUp = document.getElementById('touchUp');
            const touchLeft = document.getElementById('touchLeft');
            const touchRight = document.getElementById('touchRight');
            const touchDown = document.getElementById('touchDown');
            const touchFire = document.getElementById('touchFire');
            const touchBomb = document.getElementById('touchBomb');

            function setKey(key, state, e) {
                if (e) { e.preventDefault(); e.stopPropagation(); }
                keys[key] = state;
                if (key === 'jump' && state) player.jumpBuffer = 10;
            }

            const btnMap = [
                { el: touchUp, key: 'jump' },
                { el: touchLeft, key: 'left' },
                { el: touchRight, key: 'right' },
                { el: touchDown, key: 'down' },
                { el: touchFire, key: 'fire' },
                { el: touchBomb, key: 'bomb' }
            ];

            btnMap.forEach(item => {
                const el = item.el, key = item.key;
                if (!el) return;
                // Touch events
                el.addEventListener('touchstart', (e) => setKey(key, true, e), { passive: false });
                el.addEventListener('touchend', (e) => setKey(key, false, e), { passive: false });
                el.addEventListener('touchcancel', (e) => setKey(key, false, e), { passive: false });
                // Mouse events
                el.addEventListener('mousedown', (e) => setKey(key, true, e));
                el.addEventListener('mouseup', (e) => setKey(key, false, e));
                el.addEventListener('mouseleave', (e) => { if (keys[key]) setKey(key, false, e); });
                el.addEventListener('contextmenu', (e) => e.preventDefault());
            });
        }

        // ----------  FULLSCREEN ----------
        function initFullscreen() {
            const btn = document.getElementById('fullscreenBtn');
            const cabinet = document.getElementById('gameCabinet');
            if (btn) {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!document.fullscreenElement) cabinet.requestFullscreen();
                    else document.exitFullscreen();
                });
                btn.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
            }
        }

        // ----------  INIT ----------
        function init() {
            resetGame();
            initTouchControls();
            initFullscreen();
            document.getElementById('restartButton').addEventListener('click', resetGame);
            document.getElementById('restartButton').addEventListener('touchstart', (e) => { e.preventDefault(); resetGame(); }, { passive: false });
            if (animFrameId) cancelAnimationFrame(animFrameId);
            animFrameId = requestAnimationFrame(gameLoop);
        }

        init();
        window.addEventListener('beforeunload', () => cancelAnimationFrame(animFrameId));
    })();
</script>
</body>
</html>
