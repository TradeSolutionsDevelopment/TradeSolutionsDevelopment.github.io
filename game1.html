<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8-bit COMMANDO ¬∑ side‚Äëscrolling levels + power‚Äëups</title>
    <meta name="description" content="Professional 8-bit run‚Äôn‚Äôgun. Three scrolling levels, enemies from both sides, 4 power‚Äëups, parallax, boss fight. Pixel perfect.">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: radial-gradient(circle at 20% 30%, #0f1f2a, #071016);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            padding: 16px;
        }
        .arcade-cabinet {
            background: #1c3840;
            padding: 25px 30px 30px;
            border-radius: 40px 40px 20px 20px;
            box-shadow: 0 20px 0 #0c1c22, 0 30px 40px rgba(0,0,0,0.8);
            border-bottom: 8px solid #2d5662;
        }
        canvas {
            display: block;
            margin: 0 auto;
            border: 8px solid #2e5665;
            border-radius: 16px;
            box-shadow: inset 0 0 0 4px #6d9eb0, 0 10px 0 #142f39;
            width: 800px;
            height: 500px;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        .panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 24px;
            color: #b9f3ff;
            text-shadow: 3px 3px 0 #0f2a30;
            background: #1f424b;
            padding: 12px 30px;
            border-radius: 60px;
            border-bottom: 8px solid #0e262c;
            font-size: 22px;
            font-weight: 900;
            letter-spacing: 3px;
        }
        .scores span {
            background: #10262e;
            padding: 8px 24px;
            border-radius: 40px;
            border-bottom: 6px solid #308595;
            color: #fdffb8;
            margin-left: 12px;
        }
        .btn {
            background: #cf4e5c;
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 32px;
            font-size: 24px;
            font-weight: bold;
            border-bottom: 8px solid #822c36;
            cursor: pointer;
            transition: 0.06s;
            font-family: 'Courier New', monospace;
            text-shadow: 3px 3px 0 #4e1e24;
            letter-spacing: 4px;
        }
        .btn:hover {
            background: #ec6a7a;
            border-bottom-width: 4px;
            transform: translateY(4px);
        }
        .legend {
            color: #b3ecff;
            font-size: 16px;
            display: flex;
            gap: 32px;
            background: #16353f;
            padding: 8px 24px;
            border-radius: 40px;
            border-bottom: 5px solid #0b1f24;
        }
        .health {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .health span {
            font-size: 28px;
        }
    </style>
</head>
<body>
<div class="arcade-cabinet">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <div class="panel">
        <div class="scores">
            üéØ SCORE <span id="scoreDisplay">00000</span>
        </div>
        <div class="scores">
            üèÜ HIGH <span id="highScoreDisplay">00000</span>
        </div>
        <button class="btn" id="restartButton">‚Üª RESTART</button>
    </div>
    <div class="legend">
        <span><i>‚Üê ‚Üí</i> MOVE</span>
        <span><i>‚Üë / SPACE</i> JUMP</span>
        <span><i>Z</i> FIRE  &nbsp; <i>X</i> BOMB</span>
        <div class="health">‚ù§Ô∏è <span id="healthDisplay">‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà</span></div>
        <span id="levelDisplay">LVL 1</span>
    </div>
</div>

<script>
    (function(){
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ----------  WORLD & CAMERA ----------
        const WORLD_WIDTH = 2800;       // each level width
        const VIEWPORT_W = 800, VIEWPORT_H = 500;
        const GROUND_Y = 440;          // world ground Y (fixed)
        
        let cameraX = 0;              // left edge of viewport in world coordinates

        // ----------  GLOBAL STATE ----------
        let gameActive = true;
        let gameOver = false;
        let levelComplete = false;
        let currentLevel = 1;
        const MAX_LEVEL = 3;
        let frame = 0;
        let animFrameId = null;

        // ----------  SCORE & HIGHSCORE ----------
        let score = 0;
        let highScore = localStorage.getItem('commandoHigh') ? parseInt(localStorage.getItem('commandoHigh')) : 0;
        let playerHealth = 6;
        const MAX_HEALTH = 6;

        // ----------  POWER-UPS ----------
        let rapidFire = false;
        let rapidTimer = 0;
        let shieldActive = false;
        let shieldTimer = 0;
        let extraBomb = false;

        // ----------  PLAYER PHYSICS ----------
        const PLAYER_WIDTH = 22, PLAYER_HEIGHT = 28;
        const GRAVITY = 0.7;
        const JUMP_FORCE = -12.2;
        const MOVE_SPEED = 4.5;

        let player = {
            x: 200, y: GROUND_Y - PLAYER_HEIGHT,
            vx: 0, vy: 0,
            onGround: false,
            facing: 1,
            walkCycle: 0,
            shootTimer: 0,
            invincible: 0,
            bombCooldown: 0,
        };

        // ----------  LEVEL DESIGN (platforms, enemy spawners) ----------
        let platforms = [];
        let enemySpawners = [];   // triggers when player passes x
        let exitDoor = null;      // x position to finish level

        // ----------  DYNAMIC ENTITIES ----------
        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let explosions = [];
        let pickups = [];

        // ----------  SPAWN CONTROL ----------
        let globalSpawnTimer = 0;

        // ----------  LEVEL DEFINITIONS ----------
        function buildLevel(level) {
            platforms = [];
            enemySpawners = [];
            exitDoor = null;

            // common ground is always there (implicit, not a platform)
            if (level === 1) {
                // jungle outpost
                platforms = [
                    { x: 400, y: 360, w: 100, h: 12 },
                    { x: 600, y: 300, w: 80, h: 12 },
                    { x: 850, y: 340, w: 90, h: 12 },
                    { x: 1150, y: 280, w: 100, h: 12 },
                    { x: 1450, y: 320, w: 90, h: 12 },
                    { x: 1700, y: 260, w: 110, h: 12 },
                    { x: 2000, y: 380, w: 80, h: 12 },
                    { x: 2300, y: 300, w: 120, h: 12 },
                ];
                // enemy spawn triggers (when camera passes x)
                enemySpawners = [
                    { x: 500, type: 'infantry', side: 'right' },
                    { x: 700, type: 'drone', side: 'left' },
                    { x: 950, type: 'infantry', side: 'right' },
                    { x: 1200, type: 'heavy', side: 'right' },
                    { x: 1400, type: 'infantry', side: 'left' },
                    { x: 1600, type: 'drone', side: 'right' },
                    { x: 1850, type: 'infantry', side: 'left' },
                    { x: 2050, type: 'heavy', side: 'right' },
                    { x: 2250, type: 'infantry', side: 'left' },
                ];
                exitDoor = { x: 2600, y: GROUND_Y - 48 };
            } else if (level === 2) {
                // industrial complex ‚Äì higher platforms
                platforms = [
                    { x: 350, y: 300, w: 100, h: 12 },
                    { x: 550, y: 240, w: 80, h: 12 },
                    { x: 750, y: 360, w: 90, h: 12 },
                    { x: 1000, y: 200, w: 100, h: 12 },
                    { x: 1250, y: 320, w: 90, h: 12 },
                    { x: 1500, y: 260, w: 110, h: 12 },
                    { x: 1800, y: 380, w: 80, h: 12 },
                    { x: 2100, y: 220, w: 120, h: 12 },
                    { x: 2400, y: 300, w: 100, h: 12 },
                ];
                enemySpawners = [
                    { x: 450, type: 'infantry', side: 'right' },
                    { x: 600, type: 'heavy', side: 'left' },
                    { x: 800, type: 'drone', side: 'right' },
                    { x: 1050, type: 'infantry', side: 'right' },
                    { x: 1300, type: 'drone', side: 'left' },
                    { x: 1550, type: 'heavy', side: 'right' },
                    { x: 1850, type: 'infantry', side: 'left' },
                    { x: 2150, type: 'drone', side: 'right' },
                    { x: 2350, type: 'heavy', side: 'left' },
                    { x: 2500, type: 'infantry', side: 'right' },
                ];
                exitDoor = { x: 2700, y: GROUND_Y - 48 };
            } else if (level === 3) {
                // boss hangar ‚Äì long, with strong enemies
                platforms = [
                    { x: 400, y: 340, w: 120, h: 12 },
                    { x: 650, y: 260, w: 100, h: 12 },
                    { x: 900, y: 200, w: 100, h: 12 },
                    { x: 1200, y: 320, w: 90, h: 12 },
                    { x: 1500, y: 260, w: 110, h: 12 },
                    { x: 1800, y: 380, w: 80, h: 12 },
                    { x: 2100, y: 220, w: 120, h: 12 },
                    { x: 2400, y: 300, w: 100, h: 12 },
                ];
                enemySpawners = [
                    { x: 500, type: 'heavy', side: 'right' },
                    { x: 700, type: 'heavy', side: 'left' },
                    { x: 950, type: 'drone', side: 'right' },
                    { x: 1250, type: 'infantry', side: 'right' },
                    { x: 1550, type: 'heavy', side: 'left' },
                    { x: 1850, type: 'drone', side: 'right' },
                    { x: 2150, type: 'infantry', side: 'left' },
                    { x: 2400, type: 'heavy', side: 'right' },
                    // boss appears after most are cleared (special spawn)
                ];
                exitDoor = { x: 2650, y: GROUND_Y - 48 };
                // additional boss spawn
                enemySpawners.push({ x: 2000, type: 'boss', side: 'right', boss: true });
            }
        }

        // ----------  INIT / RESET ----------
        function resetGame() {
            gameActive = true;
            gameOver = false;
            levelComplete = false;
            currentLevel = 1;
            score = 0;
            playerHealth = MAX_HEALTH;
            rapidFire = false;
            shieldActive = false;
            extraBomb = false;
            
            player = {
                x: 200, y: GROUND_Y - PLAYER_HEIGHT,
                vx: 0, vy: 0,
                onGround: false,
                facing: 1,
                walkCycle: 0,
                shootTimer: 0,
                invincible: 0,
                bombCooldown: 0,
            };
            bullets = [];
            enemies = [];
            enemyBullets = [];
            explosions = [];
            pickups = [];
            globalSpawnTimer = 0;
            
            buildLevel(currentLevel);
            cameraX = 0;
            updateUI();
        }

        // ----------  UI UPDATE ----------
        function updateUI() {
            let scr = String(Math.floor(score)).padStart(5, '0');
            document.getElementById('scoreDisplay').innerText = scr;
            let hscr = String(highScore).padStart(5, '0');
            document.getElementById('highScoreDisplay').innerText = hscr;
            let healthBar = '';
            for (let i=0; i<playerHealth; i++) healthBar += '‚ñà';
            document.getElementById('healthDisplay').innerText = healthBar.padEnd(6, '‚ñë');
            document.getElementById('levelDisplay').innerText = `LVL ${currentLevel}`;
        }

        // ----------  KEYBOARD ----------
        const keys = {
            left: false, right: false, jump: false, fire: false, bomb: false
        };
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            switch(e.key) {
                case 'ArrowLeft': keys.left = true; e.preventDefault(); break;
                case 'ArrowRight': keys.right = true; e.preventDefault(); break;
                case 'ArrowUp': case ' ': keys.jump = true; e.preventDefault(); break;
                case 'z': case 'Z': keys.fire = true; e.preventDefault(); break;
                case 'x': case 'X': keys.bomb = true; e.preventDefault(); break;
            }
        });
        window.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft': keys.left = false; e.preventDefault(); break;
                case 'ArrowRight': keys.right = false; e.preventDefault(); break;
                case 'ArrowUp': case ' ': keys.jump = false; e.preventDefault(); break;
                case 'z': case 'Z': keys.fire = false; e.preventDefault(); break;
                case 'x': case 'X': keys.bomb = false; e.preventDefault(); break;
            }
        });

        // ----------  COLLISION ----------
        function collides(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
        }

        // ----------  CAMERA FOLLOW ----------
        function updateCamera() {
            // player center target
            let targetX = player.x + PLAYER_WIDTH/2 - VIEWPORT_W/2;
            // clamp to world bounds
            targetX = Math.max(0, Math.min(targetX, WORLD_WIDTH - VIEWPORT_W));
            // smooth follow
            cameraX += (targetX - cameraX) * 0.1;
            if (Math.abs(cameraX - targetX) < 1) cameraX = targetX;
        }

        // ----------  PLAYER UPDATE ----------
        function updatePlayer() {
            if (!gameActive) return;
            if (playerHealth <= 0) { gameActive = false; gameOver = true; return; }

            // power-up timers
            if (rapidTimer > 0) rapidTimer--; else rapidFire = false;
            if (shieldTimer > 0) shieldTimer--; else shieldActive = false;

            // horizontal movement
            let accel = 0;
            if (keys.left) accel -= 1;
            if (keys.right) accel += 1;
            player.vx = accel * MOVE_SPEED;
            player.x += player.vx;

            // world horizontal bounds
            if (player.x < 20) player.x = 20;
            if (player.x + PLAYER_WIDTH > WORLD_WIDTH - 20) player.x = WORLD_WIDTH - PLAYER_WIDTH - 20;

            // jump
            if (keys.jump && player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
            }

            // gravity
            player.vy += GRAVITY;
            player.y += player.vy;

            // ground collision
            player.onGround = false;
            if (player.y + PLAYER_HEIGHT > GROUND_Y) {
                player.y = GROUND_Y - PLAYER_HEIGHT;
                player.vy = 0;
                player.onGround = true;
            }

            // platform collisions
            for (let pl of platforms) {
                if (player.vy >= 0) {
                    let bottom = player.y + PLAYER_HEIGHT;
                    let prevBottom = bottom - player.vy;
                    if (prevBottom <= pl.y && bottom >= pl.y &&
                        player.x + PLAYER_WIDTH > pl.x && player.x < pl.x + pl.w) {
                        player.y = pl.y - PLAYER_HEIGHT;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            }

            // facing
            if (player.vx > 0.2) player.facing = 1;
            else if (player.vx < -0.2) player.facing = -1;

            // walk animation
            if (Math.abs(player.vx) > 0.5 && player.onGround) {
                player.walkCycle = (player.walkCycle + 0.25) % 4;
            } else player.walkCycle = 0;

            // shooting
            if (keys.fire && gameActive) {
                let fireRate = rapidFire ? 5 : 14;
                if (player.shootTimer <= 0) {
                    let bulletX = player.facing === 1 ? player.x + PLAYER_WIDTH - 2 : player.x - 14;
                    bullets.push({
                        x: bulletX, y: player.y + PLAYER_HEIGHT/2 - 3,
                        w: 18, h: 6, vx: player.facing * 11, vy: 0
                    });
                    player.shootTimer = fireRate;
                }
            }
            if (player.shootTimer > 0) player.shootTimer--;

            // bomb (limited)
            if (keys.bomb && player.bombCooldown <= 0 && gameActive) {
                // clear nearby enemies
                for (let i=enemies.length-1; i>=0; i--) {
                    let e = enemies[i];
                    if (Math.abs(e.x - player.x) < 400) {
                        explosions.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 20, radius: 12 });
                        score += e.points;
                        enemies.splice(i,1);
                    }
                }
                player.bombCooldown = 240;
            }
            if (player.bombCooldown > 0) player.bombCooldown--;

            // invincibility
            if (player.invincible > 0) player.invincible--;
        }

        // ----------  SPAWN ENEMIES FROM SPAWNERS ----------
        function checkSpawners() {
            for (let i=enemySpawners.length-1; i>=0; i--) {
                let s = enemySpawners[i];
                // trigger when camera passes near or player approaches
                if (player.x > s.x - 300 && player.x < s.x + 100) {
                    // spawn enemy
                    let side = s.side; // 'left' or 'right'
                    let xPos = side === 'right' ? WORLD_WIDTH - 50 : 50;
                    let yPos = GROUND_Y - 32;
                    let type = s.type;
                    let enemy = null;

                    if (type === 'infantry') {
                        enemy = {
                            x: xPos, y: GROUND_Y - 32, w: 26, h: 30,
                            vx: side === 'right' ? -1.8 : 1.8,
                            health: 1, points: 20,
                            type: 'infantry', frame: 0, shootTimer: 40 + Math.random()*30
                        };
                    } else if (type === 'heavy') {
                        enemy = {
                            x: xPos, y: GROUND_Y - 36, w: 32, h: 34,
                            vx: side === 'right' ? -1.0 : 1.0,
                            health: 4, points: 70,
                            type: 'heavy', frame: 0, shootTimer: 30
                        };
                    } else if (type === 'drone') {
                        yPos = 200 + Math.random() * 180;
                        enemy = {
                            x: xPos, y: yPos, w: 24, h: 20,
                            vx: side === 'right' ? -2.2 : 2.2,
                            health: 1, points: 30,
                            type: 'drone', frame: 0, shootTimer: 50
                        };
                    } else if (type === 'boss' && currentLevel === 3) {
                        enemy = {
                            x: WORLD_WIDTH - 100, y: GROUND_Y - 60, w: 60, h: 60,
                            vx: -0.6, health: 25, points: 500,
                            type: 'boss', frame: 0, shootTimer: 20,
                            boss: true
                        };
                    }
                    if (enemy) enemies.push(enemy);
                    enemySpawners.splice(i,1); // trigger once
                }
            }
        }

        // ----------  ENEMY UPDATE ----------
        function updateEnemies() {
            for (let i=enemies.length-1; i>=0; i--) {
                let e = enemies[i];
                e.x += e.vx;
                e.frame = (e.frame + 0.2) % 4;

                // remove if off world
                if (e.x + e.w < -100 || e.x > WORLD_WIDTH + 100) {
                    enemies.splice(i,1); continue;
                }

                // enemy shooting
                e.shootTimer--;
                if (e.shootTimer <= 0 && gameActive && playerHealth > 0) {
                    let bulletVX = e.x > player.x ? -5.5 : 5.5;
                    if (e.type === 'drone') bulletVX *= 1.2;
                    enemyBullets.push({
                        x: e.x + (bulletVX>0? e.w : -8), y: e.y + e.h/2 - 3,
                        w: 12, h: 6, vx: bulletVX, vy: 0
                    });
                    e.shootTimer = e.type === 'heavy' ? 55 : (e.type === 'boss' ? 20 : 45);
                }

                // collision with player
                if (player.invincible <= 0 && gameActive && playerHealth > 0 && !shieldActive) {
                    if (collides({x:player.x, y:player.y, w:PLAYER_WIDTH, h:PLAYER_HEIGHT},
                                 {x:e.x, y:e.y, w:e.w, h:e.h})) {
                        let dmg = (e.type === 'heavy' || e.type === 'boss') ? 2 : 1;
                        playerHealth -= dmg;
                        player.invincible = 70;
                        if (playerHealth < 0) playerHealth = 0;
                        updateUI();
                    }
                }
            }
        }

        // ----------  BULLETS ----------
        function updateBullets() {
            for (let i=bullets.length-1; i>=0; i--) {
                let b = bullets[i];
                b.x += b.vx;
                if (b.x > WORLD_WIDTH + 100 || b.x < -100) { bullets.splice(i,1); continue; }

                for (let j=enemies.length-1; j>=0; j--) {
                    let e = enemies[j];
                    if (collides({x:b.x, y:b.y, w:b.w, h:b.h},
                                 {x:e.x, y:e.y, w:e.w, h:e.h})) {
                        bullets.splice(i,1);
                        e.health -= 1;
                        if (e.health <= 0) {
                            score += e.points;
                            if (score > highScore) { highScore = score; localStorage.setItem('commandoHigh', highScore); }
                            explosions.push({ x: e.x + e.w/2, y: e.y + e.h/2, life: 20, radius: 12 });
                            // chance to drop power-up
                            if (Math.random() < 0.2) {
                                pickups.push({
                                    x: e.x, y: e.y, w: 16, h: 16,
                                    type: ['health','rapid','shield','bomb'][Math.floor(Math.random()*4)],
                                    vx: -1, life: 400
                                });
                            }
                            enemies.splice(j,1);
                        }
                        break;
                    }
                }
            }
        }

        function updateEnemyBullets() {
            for (let i=enemyBullets.length-1; i>=0; i--) {
                let eb = enemyBullets[i];
                eb.x += eb.vx;
                if (eb.x < -100 || eb.x > WORLD_WIDTH + 100) { enemyBullets.splice(i,1); continue; }

                if (player.invincible <= 0 && gameActive && playerHealth > 0 && !shieldActive) {
                    if (collides({x:player.x, y:player.y, w:PLAYER_WIDTH, h:PLAYER_HEIGHT},
                                 {x:eb.x, y:eb.y, w:eb.w, h:eb.h})) {
                        playerHealth -= 1;
                        player.invincible = 50;
                        enemyBullets.splice(i,1);
                        if (playerHealth < 0) playerHealth = 0;
                        updateUI();
                    }
                }
            }
        }

        // ----------  PICKUPS ----------
        function updatePickups() {
            for (let i=pickups.length-1; i>=0; i--) {
                let p = pickups[i];
                p.x += p.vx;
                p.life--;
                if (p.life <= 0 || p.x < -100) { pickups.splice(i,1); continue; }
                if (collides({x:player.x, y:player.y, w:PLAYER_WIDTH, h:PLAYER_HEIGHT},
                             {x:p.x, y:p.y, w:p.w, h:p.h})) {
                    // apply power-up
                    if (p.type === 'health') {
                        playerHealth = Math.min(MAX_HEALTH, playerHealth + 2);
                    } else if (p.type === 'rapid') {
                        rapidFire = true;
                        rapidTimer = 600;
                    } else if (p.type === 'shield') {
                        shieldActive = true;
                        shieldTimer = 600;
                    } else if (p.type === 'bomb') {
                        player.bombCooldown = 0; // allow instant bomb use
                    }
                    pickups.splice(i,1);
                    updateUI();
                }
            }
        }

        // ----------  EXPLOSIONS ----------
        function updateExplosions() {
            for (let i=explosions.length-1; i>=0; i--) {
                let ex = explosions[i];
                ex.life -= 1.5;
                ex.radius += 1.5;
                if (ex.life <= 0) explosions.splice(i,1);
            }
        }

        // ----------  LEVEL PROGRESSION ----------
        function checkExit() {
            if (exitDoor && player.x > exitDoor.x - 30 && !levelComplete) {
                // clear remaining enemies? maybe bonus
                levelComplete = true;
                if (currentLevel < MAX_LEVEL) {
                    currentLevel++;
                    buildLevel(currentLevel);
                    // reposition player at start of new level
                    player.x = 200;
                    player.y = GROUND_Y - PLAYER_HEIGHT;
                    cameraX = 0;
                    // carry over health, score, power-ups? reset some
                    rapidFire = false; rapidTimer = 0;
                    shieldActive = false; shieldTimer = 0;
                    enemies = [];
                    enemyBullets = [];
                    pickups = [];
                    levelComplete = false;
                } else {
                    // game beaten
                    gameActive = false;
                    gameOver = false; // victory
                }
            }
        }

        // ----------  RENDERING (camera transform) ----------
        function drawWorld() {
            // clear
            ctx.clearRect(0,0,VIEWPORT_W,VIEWPORT_H);
            
            // ---- parallax background (relative to camera) ----
            let bgOffset = cameraX * 0.3;
            ctx.fillStyle = '#14323b'; ctx.fillRect(0,0,VIEWPORT_W,120);
            ctx.fillStyle = '#1d4a55'; ctx.fillRect(0,120,VIEWPORT_W,70);
            ctx.fillStyle = '#25626b'; ctx.fillRect(0,190,VIEWPORT_W,60);
            
            // hills
            ctx.fillStyle = '#2a6b4a';
            for (let i=0;i<5;i++) {
                let x = (i*200 - bgOffset) % 900 - 100;
                ctx.beginPath();
                ctx.moveTo(x, 300);
                ctx.quadraticCurveTo(x+80, 220, x+160, 300);
                ctx.fill();
            }

            // ground (world coordinates -> screen)
            let groundScreenY = GROUND_Y - cameraX*0; // no vertical parallax
            ctx.fillStyle = '#4b6a3b'; 
            ctx.fillRect(0, groundScreenY-6, VIEWPORT_W, 20);
            ctx.fillStyle = '#6d8f4d';
            ctx.fillRect(0, groundScreenY-2, VIEWPORT_W, 8);
            
            // platforms (transform world->screen)
            ctx.shadowBlur = 0;
            platforms.forEach(p => {
                let sx = p.x - cameraX;
                if (sx + p.w > 0 && sx < VIEWPORT_W) {
                    ctx.fillStyle = '#5c4934'; ctx.fillRect(sx, p.y, p.w, p.h);
                    ctx.fillStyle = '#846b4a'; ctx.fillRect(sx+2, p.y-2, p.w-4, 5);
                }
            });

            // exit door
            if (exitDoor) {
                let sx = exitDoor.x - cameraX;
                ctx.fillStyle = '#ac8c5a'; ctx.fillRect(sx, exitDoor.y, 30, 48);
                ctx.fillStyle = '#c9ae74'; ctx.fillRect(sx+8, exitDoor.y-8, 14, 12);
            }

            // enemies
            enemies.forEach(e => {
                let sx = e.x - cameraX;
                if (sx + e.w > 0 && sx < VIEWPORT_W) {
                    // enemy drawing (simplified but colored)
                    if (e.type === 'infantry') {
                        ctx.fillStyle = '#9d4e3a'; ctx.fillRect(sx, e.y, e.w, e.h);
                    } else if (e.type === 'heavy') {
                        ctx.fillStyle = '#6a4e4e'; ctx.fillRect(sx, e.y, e.w, e.h);
                    } else if (e.type === 'drone') {
                        ctx.fillStyle = '#467c7c'; ctx.fillRect(sx, e.y, e.w, e.h);
                    } else if (e.type === 'boss') {
                        ctx.fillStyle = '#b34b4b'; ctx.fillRect(sx, e.y, e.w, e.h);
                        ctx.fillStyle = '#d48c48'; ctx.fillRect(sx+10, e.y-10, 20, 12);
                    }
                }
            });

            // bullets
            bullets.forEach(b => {
                let sx = b.x - cameraX;
                ctx.fillStyle = '#ffd966'; ctx.fillRect(sx, b.y, b.w, b.h);
            });
            enemyBullets.forEach(b => {
                let sx = b.x - cameraX;
                ctx.fillStyle = '#ff7474'; ctx.fillRect(sx, b.y, b.w, b.h);
            });

            // pickups
            pickups.forEach(p => {
                let sx = p.x - cameraX;
                ctx.fillStyle = '#4caf7a'; ctx.fillRect(sx, p.y, p.w, p.h);
                ctx.fillStyle = 'white'; ctx.font = '16px monospace';
                if (p.type === 'health') ctx.fillText('‚ù§Ô∏è', sx, p.y+14);
                else if (p.type === 'rapid') ctx.fillText('‚ö°', sx, p.y+14);
                else if (p.type === 'shield') ctx.fillText('üõ°Ô∏è', sx, p.y+14);
                else if (p.type === 'bomb') ctx.fillText('üí£', sx, p.y+14);
            });

            // explosions
            explosions.forEach(ex => {
                let sx = ex.x - cameraX;
                ctx.fillStyle = `rgba(255, 140, 30, ${ex.life/30})`;
                ctx.beginPath(); ctx.arc(sx, ex.y, ex.radius, 0, 2*Math.PI);
                ctx.fill();
            });

            // player (with invincibility flash)
            if (player.invincible % 8 < 4 || player.invincible === 0) {
                let px = player.x - cameraX, py = player.y;
                ctx.fillStyle = shieldActive ? '#7fb3d5' : '#3a7251';
                ctx.fillRect(px+2, py+2, 20, 22);
                ctx.fillStyle = '#5a8f4c'; ctx.fillRect(px+6, py-2, 12, 10);
                ctx.fillStyle = '#ab8b3b'; ctx.fillRect(player.facing===1? px+16 : px, py, 8, 6);
                // gun
                ctx.fillStyle = '#414141';
                if (player.facing === 1) ctx.fillRect(px+20, py+10, 14, 4);
                else ctx.fillRect(px-10, py+10, 14, 4);
            }
        }

        // ----------  GAME LOOP ----------
        function gameLoop() {
            if (gameActive) {
                updateCamera();
                checkSpawners();
                updatePlayer();
                updateBullets();
                updateEnemies();
                updateEnemyBullets();
                updatePickups();
                updateExplosions();
                checkExit();

                if (playerHealth <= 0) {
                    gameActive = false;
                    gameOver = true;
                }
                updateUI();
            }

            drawWorld();

            // game over / victory screen
            if (!gameActive) {
                ctx.fillStyle = '#000000aa';
                ctx.fillRect(220, 190, 360, 90);
                ctx.fillStyle = '#ffe98c';
                ctx.font = '36px "Courier New", monospace';
                ctx.textAlign = 'center';
                if (gameOver) ctx.fillText('‚ùå GAME OVER', 400, 245);
                else if (currentLevel >= MAX_LEVEL) ctx.fillText('üèÅ VICTORY!', 400, 245);
                else ctx.fillText('- PAUSE -', 400, 245);
            }

            frame++;
            animFrameId = requestAnimationFrame(gameLoop);
        }

        // restart button
        document.getElementById('restartButton').addEventListener('click', resetGame);

        // start
        resetGame();
        gameLoop();

        window.addEventListener('beforeunload', () => cancelAnimationFrame(animFrameId));
    })();
</script>
</body>
</html>
